{"author":{"id":"d82e3b0277388fab1285e702dfba0ce3b709e1919233977abaeab636c4c57550"},"ops":[{"type":3,"timestamp":1672667573,"nonce":"QoZaqxHZ/vHtxxiSwYiciydXTxo=","metadata":{"github-id":"IC_kwDOCGKeh85RmL__","github-url":"https://github.com/git-bug/git-bug/issues/130#issuecomment-1368965119"},"message":"Per our digression in #963, I wanted to add a few comments related to a) actually signing commits (and as stated above identities) and impacts that this might have on the bridges.\n\na.  It's been a couple of years since I worked on GPG in Go but my recollection is that none of the Go libraries implements the new `keybox` storage for private keys.  My recollection is that GPG generates all new keys into the `keybox` and that GPG never reads the value of the key (in normal operation - export does).  Instead, GPG requires the use of the `gpg-agent` (which will be started if it isn't already started) and that all signing, verifying, encrypting and decrypting will be delegated to the agent.  The main idea is that operations requiring a private key aren't executed by the user's GPG program but rather by an already running/trusted service.  In my case (my private keys are on my Yubikeys), I believe there's a marker in the `keybox` that indicates the scdaemon should be used for the actual value (but this is still handled by the agent).  In short (haha), this would tend to contradict the bullet above that states:\n\u003e design \u0026 implement the storage of the corresponding private keys somewhere in the system\n\nb.  The other problem I see with the above is that when a bridge is importing an identity, it should NOT have access to the private key to sign the created (or updated) identity - and yet it needs to create the users and make sure they're not adopted by the wrong user even without those signatures.  I'm also wondering about the \"protection rules\" above - are there any vulnerabilities to a user who manually edits their project's `.git/config` file or uses `git` plumbing commands?","files":null}]}