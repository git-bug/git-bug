{"author":{"id":"3998add589f6a09cf4bdf0e85e5481d2c48b8a757edd699a79a0c929ab5005db"},"ops":[{"type":3,"timestamp":1684261102,"nonce":"p2lmFmdCNLJxGhCNPZhGny8Mq+Y=","metadata":{"github-id":"IC_kwDOCGKeh85cZWc9","github-url":"https://github.com/git-bug/git-bug/issues/1068#issuecomment-1550149437"},"message":"I think there is two dimensions for this:\n- how those reference are expressed and stored\n- what those references point to\n\nLet's start by clearing some things:\n\u003e I have noticed that each time I clone the repo and pull from a bridge, the issues are given a new set of hashes/IDs.\n\nThis is \"normal\", for some definition of normal. As git-bug is a decentralized system, when you import bugs with a bridge, you can't know if some other machine somewhere in the world has done so already. It's just impossible. So that creates duplicate bugs in git-bug.\n\nIt's also impossible or ill-advised to generate the same hash, for multiple reasons. One sufficient reasons is that the original bug data will contain the date of creation, which in turn change the hash. That bug will also have an author (you) which will likely be different than on the other machine.\n\nNow, **how those reference are expressed and stored**. What I suppose we could do is to have special markers in the stored text. `git-bug` would understand those and generate the appropriate link in each UI. Possibly, if this marker point to a git-bug object, it could be recorded as a dependency in the graph (similar as for files, see https://github.com/MichaelMure/git-bug/blob/master/doc/model.md#entities-are-stored-in-git-objects), so that it get pulled together.\n\nAs for **what those references point to**, that's where we can be clever. We can point to a git-bug ID of course, but not only. When a bridge import a bug, it adds metadata to the git-bug bug. For example the github bridge include the github ID and URL as metadata. Those won't change.\n\nSo we have **any** or **multiple** reference for the same marker, and have the core+UI figure out what makes sense and how to display it.","files":null},{"type":6,"timestamp":1684261117,"nonce":"69YrGHQs08/4AduKfY4JW6tZ6eI=","metadata":{"github-id":"UCE_lALOCGKeh85cZWc9zjFmqXM"},"target":"34bd86332ea224b0b3818fc69b2a74f25ce0a3c8ee7c680126717aa57ba21edb","message":"I think there is two dimensions for this:\n- how those reference are expressed and stored\n- what those references point to\n\nLet's start by clearing some things:\n\u003e I have noticed that each time I clone the repo and pull from a bridge, the issues are given a new set of hashes/IDs.\n\nThis is \"normal\", for some definition of normal. As git-bug is a decentralized system, when you import bugs with a bridge, you can't know if some other machine somewhere in the world has done so already. It's just impossible. So that creates duplicate bugs in git-bug.\n\nIt's also impossible or ill-advised to generate the same hash, for multiple reasons. One sufficient reasons is that the original bug data will contain the date of creation, which in turn change the hash. That bug will also have an author (you) which will likely be different than on the other machine.\n\nNow, **how those reference are expressed and stored**. What I suppose we could do is to have special markers in the stored text. `git-bug` would understand those and generate the appropriate link in each UI. Possibly, if this marker point to a git-bug object, it could be recorded as a dependency in the graph (similar as for files, see https://github.com/MichaelMure/git-bug/blob/master/doc/model.md#entities-are-stored-in-git-objects), so that it get pulled together.\n\nAs for **what those references point to**, that's where we can be clever. We can point to a git-bug ID of course, but not only. When a bridge import a bug, it adds metadata to the git-bug bug. For example the github bridge include the github ID and URL as metadata. Those won't change.\n\nSo we have **any** or **multiple** references for the same marker, and have the core+UI figure out what makes sense and how to display it.","files":null}]}