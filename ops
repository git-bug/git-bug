{"author":{"id":"20fb3f7a72e9332ee70d77e89c72d39175856b322abf72a6d69d69536651805a"},"ops":[{"type":1,"timestamp":1553339925,"nonce":"zkmZdT3CRwHVkJV93OLNxS5h4YA=","metadata":{"github-id":"MDU6SXNzdWU0MjQ0OTAwNDE=","github-url":"https://github.com/git-bug/git-bug/issues/105","origin":"github"},"title":"Data model: why deltas and not snapshots?","message":"Hello! Thanks for your amazing work. I have a big need for a decent distributed issue tracker and git-bug looks very promising. I also look for a way to grab all GitHub issue and pull request data, and the recent exporter work sounds like what I need.\n\nI've read the [data model](https://github.com/MichaelMure/git-bug/blob/master/doc/model.md) and got some itching questions. Apologies if this was discussed previously and I would appreciate any pointers to read.\n\n## 1. Why store deltas instead of snapshots?\n\n\u003e Anybody can create and edit bugs at the same time as you. To deal with this problem, you need a way to merge these changes in a meaningful way. Instead of storing directly the final bug data, we store a series of edit `Operation`.\n\nFirst thought as I read this: didn't Git solve this?\n\nOne of the major breakthroughs of Git was to store snapshots of files instead of deltas like SVN did. The hope was that tools would evolve to compute better and better deltas from two snapshots. And it happened, modern diff and merge tools are pretty smart. In Git anybody can create and edit files at the same time as I, and to deal with this problem we have merge tools and strategies.\n\nFrom this perspective, I'm puzzled by the choice to store Operations (deltas) over snapshots. At any given moment you don't have complete versions (snapshots) of bugs - to get the state of bugs you need to compute deltas from the very beginning. This means you can't edit bugs as simple files and commit them with Git, you need to always use special software that talks the language of Operations' storage format.\n\nBugs and comments could be simple Markdown files with YAML metadata on top (compatible with the popular \"front matter\" thing). Alternatively, bugs could be metadata files without body with optional .md description file (or, description can be implemented as first comment). In any case I'd suggest YAML over JSON.\n\n## 2. Rebase is not the best merge strategy\n\n\u003e Now that we have this, we can easily merge our bugs without conflict. When pulling bug's update from a remote, we will simply add our new operations (that is, new `Commit`), if any, at the end of the chain. In git terms, it's just a `rebase`.\n\nThis reads like it will apply remote changes on top of mine and always override what I had. If state snapshots are stored instead of deltas (following a common Git way), I could fetch remote changes and decide myself how to integrate them with my state (using rebase or merge or whatever). This would allow standard Git ways to be used, e.g. a ton of people have cloned the repo but a select few of them are considered \"upstreams\" by everyone else for their better curation work.","files":null}]}