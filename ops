{"author":{"id":"3998add589f6a09cf4bdf0e85e5481d2c48b8a757edd699a79a0c929ab5005db"},"ops":[{"type":3,"timestamp":1533504936,"nonce":"ga0O8dyyQX9gQg5WJ0CRPl37RG8=","metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQxMDU0OTgwMA==","github-url":"https://github.com/git-bug/git-bug/issues/9#issuecomment-410549800"},"message":"Damn, how come people find this repo when I didn't advertise it ?\n\n\u003e I noticed the OT based approach for the Data Model for a BUG. Wondering if you think this is better than the CRDT approach ?\n\nI had the idea to use CRDTs in the beginning (https://github.com/MichaelMure/git-bug/blob/5751cd8f6befa7e5dab6e647d9747f5f20f188b3/notes#L39-L54), but thinking more about it I found out that I could leverage git's datastructure and guarantees to solve the conflict problem. For example, git will, by default, refuse to update a reference in a non-fast-forward way. That means that you can't remove a commit and the associated operations. You can only add some new one. That means that you have to rebase properly your operations before pushing your changes. You don't need to have a git-bug aware remote. As a general rule, I think staying as close as possible to the normal git use-case make git-bug a less special use-case, and reduce the risk of incompatibility.\nThat said, it might be a good idea to have a hook available that an admin could install to make refuse a push with invalid data.\n\n\u003e But anyway i was thinking about how lots of users have to fork and then manage setting up the brnahc and then doing a PR. It can be tricky for new golang users. SO i want to suggest that this be incorporated later. I saw a repo in golang just the other day that did this.\n\nHmm, I'm not sure what you are talking about, can you clarify ? If you mean that user have to clone the depo and use git-bug to submit a new bug, well, no necessarily. The web UI is designed to, in the future, \nbe used as a public interface as well. It would need have some kind of authentication to identify users though.\n\n\u003e The code base looks really clean and easy to follow and i want to congratulate you on this excellent work.\n\nThanks !\n\n\u003e In terms of a github server, do you envisage users using gitea or other ?\n\nYou can use whatever git server you want, whatever network transport you want. Even a repo in a mounted filesystem can be used as a remote if you want to. That's how the tests are run.","files":null},{"type":6,"timestamp":1533505400,"nonce":"dznTX0L/kIjRnXQUMkgSs75/0zQ=","metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDExNjI2OTMxMQ=="},"target":"ae870023ee1f9755717730d3ea7cd177eb6e1f2be386baf78f36244f42d7aed7","message":"Damn, how come people find this repo when I didn't advertise it ?\n\n\u003e I noticed the OT based approach for the Data Model for a BUG. Wondering if you think this is better than the CRDT approach ?\n\nI had the idea to use CRDTs in the beginning (https://github.com/MichaelMure/git-bug/blob/5751cd8f6befa7e5dab6e647d9747f5f20f188b3/notes#L39-L54), but thinking more about it I found out that I could leverage git's datastructure and guarantees to solve the conflict problem. For example, git will, by default, refuse to update a reference in a non-fast-forward way. That means that you can't remove a commit and the associated operations. You can only add some new one. That means that you have to rebase properly your operations before pushing your changes. You don't need to have a git-bug aware remote. As a general rule, I think staying as close as possible to the normal git use-case make git-bug a less special use-case, and reduce the risk of incompatibility.\nThat said, it might be a good idea to have a hook available that an admin could install to make refuse a push with invalid data.\n\n\u003e But anyway i was thinking about how lots of users have to fork and then manage setting up the brnahc and then doing a PR. It can be tricky for new golang users. SO i want to suggest that this be incorporated later. I saw a repo in golang just the other day that did this.\n\nHmm, I'm not sure what you are talking about, can you clarify ? If you mean that user have to clone the depo and use git-bug to submit a new bug, well, no necessarily. The web UI is designed to, in the future, \nbe used as a public interface as well. It would need have some kind of authentication to identify users though.\n\n\u003e The code base looks really clean and easy to follow and i want to congratulate you on this excellent work.\n\nThanks ! Also, golang being quite picky about circular-reference force you to have a cleaner design ...\n\n\u003e In terms of a github server, do you envisage users using gitea or other ?\n\nYou can use whatever git server you want, whatever network transport you want. Even a repo in a mounted filesystem can be used as a remote if you want to. That's how the tests are run.","files":null},{"type":6,"timestamp":1533505580,"nonce":"0CrIs3wCqduhH297jpdF8iE9h1I=","metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDExNjI2OTQ2MQ=="},"target":"ae870023ee1f9755717730d3ea7cd177eb6e1f2be386baf78f36244f42d7aed7","message":"Damn, how come people find this repo when I didn't advertise it ?\n\n\u003e I noticed the OT based approach for the Data Model for a BUG. Wondering if you think this is better than the CRDT approach ?\n\nI had the idea to use CRDTs in the beginning (https://github.com/MichaelMure/git-bug/blob/5751cd8f6befa7e5dab6e647d9747f5f20f188b3/notes#L39-L54), but thinking more about it I found out that I could leverage git's datastructure and guarantees to solve the conflict problem. For example, git will, by default, refuse to update a reference in a non-fast-forward way. That means that you can't remove a commit and the associated operations. You can only add some new one. That means that you have to rebase properly your operations before pushing your changes. You don't need to have a git-bug aware remote. As a general rule, I think staying as close as possible to the normal git use-case make git-bug a less special use-case, and reduce the risk of incompatibility.\nThat said, it might be a good idea to have a hook available that an admin could install to make refuse a push with invalid data.\n\n\u003e But anyway i was thinking about how lots of users have to fork and then manage setting up the brnahc and then doing a PR. It can be tricky for new golang users. SO i want to suggest that this be incorporated later. I saw a repo in golang just the other day that did this.\n\nHmm, I'm not sure what you are talking about, can you clarify ? If you mean that user have to clone the depo and use git-bug to submit a new bug, well, no necessarily. The web UI is designed to, in the future, \nbe used as a public interface as well. It would need to have some kind of authentication to identify users though.\n\n\u003e The code base looks really clean and easy to follow and i want to congratulate you on this excellent work.\n\nThanks ! Also, golang being quite picky about circular-reference force you to have a cleaner design ...\n\n\u003e In terms of a github server, do you envisage users using gitea or other ?\n\nYou can use whatever git server you want, whatever network transport you want. Even a repo in a mounted filesystem can be used as a remote if you want to. That's how the tests are run.","files":null}]}