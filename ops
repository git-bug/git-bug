{"author":{"id":"3998add589f6a09cf4bdf0e85e5481d2c48b8a757edd699a79a0c929ab5005db"},"ops":[{"type":1,"timestamp":1567622176,"nonce":"VpN89ab4QgVSniL/M44Cc41+ylw=","metadata":{"github-id":"MDU6SXNzdWU0ODkzMjY0Mzk=","github-url":"https://github.com/git-bug/git-bug/issues/212","origin":"github"},"title":"Reflections on the change needed in the data model","message":"It appears to me that some changes are needed to fix some current problems or support more usecase.\n\nTo help structure the reflection, let's start with a ...\n\n## Threat model\n\nLevel 1:\n- all actors behave in good faith and run the normal software\n- the goal is to prevent accidental tempering or corruption of the data, and in particular, changes or suppression in the semantic of a bug.\n\nIn essence, this threat model represent the normal workflow of git-bug where all the actors are identified and validated, either by being authorised to push to a repository, being a source repository being pulled, or by being a bot of some sort with the same level of credential.\n\nBeing resistant to this threat model is the minimal acceptable protection that git-bug should provide.\n\nLevel 2:\n- bad actor(s) try to actively temper or corrupt the data, and in particular, try to change, inject or suppress some semantic information of a bug.\n- they can run a custom version of the software\n\nThis threat model represent a fully decentralized workflow for git-bug where the actors are not fully identified and validated.\n\nBeing resistant to this threat model is **not** a goal of git-bug at the moment. This threat model exist to be able to identify where git-bug might fail in this scenario and possibly to make educated design decision towards supporting it at some point. In any case, being resistant to this thread model automatically imply being resistant to the first one and might lead to more elegant solution.\n\n## Point of attention\n\n- ordering of the operation inside a bug\n    - reordering of existing operation inside an OperationPack\n    - reordering of existing OperationPack\n- insertion of an extra operation\n\n## Problem#1: operation's ID collision\n\nAs of now, it's fairly easy to create collision of Operation's ID, especially for simple Operation like SetStatusOperation. Create two \"close\" operation within the same second and you have a collision. Essentially, there is either not enough entropy or no mechanism to ensure uniqueness (or really *enough* uniqueness as we are dealing with a distributed system).\n\nPossible solutions:\n- add some sort of arbitrary counter\n    - not great as it doesn't give uniqueness guarantee (two actors can select the same next index as they don't have the complete knowledge of the system)\n- increase the resolution of the time field\n    - make accidental collision way less likely\n- add a \"random data\" field like in `identity.Version`\n- (?) add a Vector clock per bug with a clock value for each operation, making them unique, or another solution for Problem#2\n\n## Problem#2: support decentralized workflow \u0026 operation ordering\n\nAs of now, git-bug enforce to have a single linear chain of operations. Those operations are interpreted in the order defined by this chain, which means that the oldest operation take precedence. If an operation's semantic doesn't make sense after the action of another, it is ignored.\n\nWhen someone want to push new operation, git-bug enforce this single chain of operation, and enforce a fast-forward only update. This means that if a conflict exist, the sender has to retrieve the distant chain (pull), and apply his new operations on top before pushing.\n\nThis method works well with a centralized sharing topology (which would I expect be 90% of the actual usage), but it's much less clear to me what happen with multiple repositories push/pulling on each other. It would be very valuable to ensure that such a scenario works correctly as it would allow for a fully decentralized workflow.\n\nAt the same time, a solution to this problem has to ensure that a malicious actor cannot inject or reorder operations as it would effectively allow to disable others or temper the semantic of a bug.\n\nPotential solutions:\n- add a Lamport clock's value on each operations\n- add a vector clock's value on each operation, with the process's id being the user'id\n- add on each operation the ID of the previous operation\n- allow a non-linear DAG of operations, with a computed merge. Inspiration: https://github.com/matrix-org/matrix-doc/blob/erikj/state_res_msc/proposals/1442-state-resolution.md\n\n## Selected solutions (WIP)\n\n### data validation\n\nBug's operation are checked to make sure that no operations have the same ID. If they do, the bug is considered invalid, which will prevent 1) adding operations that would create a collision and 2) merge a remote bug with a collision. This will mechanically prevent a bad bug from propagating in the network.\n\n### millisecond timestamps\n\nAt the moment, timestamps are classic unix timestamp, that is with a second precision. Switching to millisecond could help adding more entropy to each operation and prevent accidental collision. Not a silver bullet, but fairly easy to do and low cost.","files":null}]}