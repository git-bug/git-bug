{"author":{"id":"3998add589f6a09cf4bdf0e85e5481d2c48b8a757edd699a79a0c929ab5005db"},"ops":[{"type":3,"timestamp":1672687861,"nonce":"rWp8VfqugVvxkZXBQ5sXtBCEhmo=","metadata":{"github-id":"IC_kwDOCGKeh85Rm8xL","github-url":"https://github.com/git-bug/git-bug/issues/130#issuecomment-1369164875"},"message":"Shot answer: I don't think those are issues, just some area in the design that need more than a naive thinking.\n\nDisclaimer: I never used GPG so it's a bit uncharted territory for me.\n\n\u003e design \u0026 implement the storage of the corresponding private keys somewhere in the system\n\nWhat I meant by that is really just \"the private key is not stored in the git entity, only the public key\". After that, where and how the private key is stored doesn't matter, as long as we are able to:\n1. sign git commits\n2. verify git signatures\n\nNote: those requirements don't imply that we have access to the private key. It would be perfectly reasonable to have those operations happening externally to git-bug, in the agent or a yubikey. I just implemented that part a bit naively for now.\n\nAs for the identity data structure, that would mean we would store there only some kind of identifier for the private key (fingerprint, ...), to be able to search it on the user system. Once found, git-bug should make sure that it's indeed the key matching the public key.\n\nAs for the actual code that would do that, my recollection matches yours. It might be difficult to find code that allows us to have this working easily, with great and transparent UX, and able to reach whatever the user normally use.\n\n\u003e b. The other problem I see with the above is that when a bridge is importing an identity, it should NOT have access to the private key to sign the created (or updated) identity - and yet it needs to create the users and make sure they're not adopted by the wrong user even without those signatures.\n\nMy thinking about this is that a bridge would only:\n- create an identity without public key (aka *unprotected*), if no keys are known\n- create an identity with public key (aka *protected*), if some keys are known\n- update an unprotected identity, either to update identity details or add some public keys (making it *protected*)\n\nOnce the identity is protected, the bridge can't touch it anymore. This could be a little weird but I suppose that's an acceptable UX if we consider that identities \"live their lifes\" in git-bug once imported. Possibly we can add the following  for completeness:\n- update the user *protected* identity, as the private key is available (could be generalized as \"any identity of which we have access to the private key)\n\n\u003e  I'm also wondering about the \"protection rules\" above - are there any vulnerabilities to a user who manually edits their project's .git/config file or uses git plumbing commands?\n\nObviously more pair of eyes on this would be great but I think it's OK? Let's try to unpack some obvious scenario:\n\n1. Bad actor want to adopt an *unprotected* identity\n\nThis one is obvious: it's unprotected. Nothing prevent anyone to do that. Add a public key.\n\n2. Bad actor want to adopt a *protected* identity with a single commit\n\nIn the data structure would be a single version, **with** one or more public key, **without** a git commit signature. There is no proper crypto signature, yet we have a hash of the full payload, that include the public key.\n- any update on another entity is required to be signed by one of those keys, so no abuse possible there.\n    - if the \"same\" identity is created on another machine, it would have a different ID, and being able to fake that would require being able to do a hash collision (sha256)\n    - as we have a single commit, there is no question of said identity not being fully propagated in the git remotes, it either exist fully replicated or not\n- as git-bug verify that the identity ID is the hash of the full payload, the bad actor can't tamper the payload without changing the ID, which would be dropped by other clients\n\nNow, once we have a matching private key, it would make sense to add a properly signed commit, just as precaution. Which brings us to ...\n\n3. Bad actor want to adopt a *protected* identity, with more commit(s) after the one introducing the public key\n\nIn the data structure would be 0+ commit without public key, followed by 1 commit with 1+ public key, followed by 1+ commit signed by a key present and valid in the previous commit.\n\nMost of the previous reasoning still apply:\n- once we have a signed git commit, we have a fully signed chain. It's not possible to tamper anything without having the private key\n- bad actor can't use a leaked private key **if** the author has updated its identity to remove the leaked key (aka revoked it)\n\nThe big difference is that it's now possible to have that identity non-uniformly replicated in the git remotes. There is actually two sub-scenario here:\n1. someone push **incomplete** changes, either only entities updates or only identity updates. This really shouldn't happen as a git push either succeed or not and we are (since recently) pushing all changes in one go. FYI: once the push is done, git-bug fully \"import and accept\" the identities changes first, for the simple fact that we want to have all identities around before proceeding with the rest.\n2. in a network of remotes, some remotes have one version of the identity, some other have another (older or younger). We won't consider here the case where the author makes, from a V1 identity version, a V2 on one machine and a v2' on another. That would create a network partition and ... just don't. It's a separate issue, due to identities requiring a purely linear chain of commits instead of accepting a DAG (https://github.com/MichaelMure/git-bug/blob/95911100823b5c809225d664de74ad2d64e91972/cache/identity_subcache.go#L28-L33).\n\nIMHO the scenario 1 is unrealistic, so onward for scenario 2:\n\n// TO BE CONTINUED, I'M HUNGRY","files":null}]}