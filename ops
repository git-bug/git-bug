{"author":{"id":"3998add589f6a09cf4bdf0e85e5481d2c48b8a757edd699a79a0c929ab5005db"},"ops":[{"type":3,"timestamp":1556794670,"nonce":"8FZw863i6ETTY/XWsmSfCCeNokE=","metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ4ODYzMDcwNw==","github-url":"https://github.com/git-bug/git-bug/issues/130#issuecomment-488630707"},"message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [ ] implement the storage of public keys in the identities + UI/UX to interact with\n1. [ ] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [ ] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":6,"timestamp":1618683899,"nonce":"IY1cF1KTU3eYRlShUtJAq0hMomY=","metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyNzI4NDQ2"},"target":"636381d58699219771f4497469c7afd896a461124abfe5e09f7b3e0141532482","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [x] implement the storage of public keys in the identities + UI/UX to interact with\n1. [ ] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [ ] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":6,"timestamp":1618683907,"nonce":"WzJeIX/v7Ra8e2nGTvdCtkCaFYY=","metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyNzI4NDU0"},"target":"636381d58699219771f4497469c7afd896a461124abfe5e09f7b3e0141532482","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [x] implement the storage of public keys in the identities + UI/UX to interact with\n1. [x] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [ ] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":6,"timestamp":1618683910,"nonce":"xyKq1edIWSsdgba+ADk+KHk2fKI=","metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyNzI4NDU4"},"target":"636381d58699219771f4497469c7afd896a461124abfe5e09f7b3e0141532482","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [x] implement the storage of public keys in the identities + UI/UX to interact with\n1. [x] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [x] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":2,"timestamp":1557086705,"nonce":"mRg1p+OK0tg7gBN+d1YdkKJ5v8o=","metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50MjMxOTc2NjcxOA=="},"title":"Identity management: step two","was":"Identity management: step two"},{"type":3,"timestamp":1587768905,"nonce":"LSmFwx7txiS4l/SOG1NSn6SPXjk=","metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTI3MTYwMA==","github-url":"https://github.com/git-bug/git-bug/issues/130#issuecomment-619271600"},"message":"Some of this is happening in https://github.com/MichaelMure/git-bug/pull/376","files":null},{"type":3,"timestamp":1618683973,"nonce":"IIDcsfoSr5Ogp6KiA37qlqvmTBE=","metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDgyMTg2NjUyMQ==","github-url":"https://github.com/git-bug/git-bug/issues/130#issuecomment-821866521"},"message":"Still a lot to do, but git-bug's core can now store/load crypto keys and check signatures.","files":null}]}