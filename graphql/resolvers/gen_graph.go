// Code generated by github.com/vektah/gqlgen, DO NOT EDIT.

package resolvers

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"
	time "time"

	bug "github.com/MichaelMure/git-bug/bug"
	operations "github.com/MichaelMure/git-bug/bug/operations"
	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

// MakeExecutableSchema creates an ExecutableSchema from the Resolvers interface.
func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(resolvers ResolverRoot) graphql.ExecutableSchema {
	return MakeExecutableSchema(shortMapper{r: resolvers})
}

type Resolvers interface {
	AddCommentOperation_date(ctx context.Context, obj *operations.AddCommentOperation) (time.Time, error)

	Bug_status(ctx context.Context, obj *bug.Snapshot) (Status, error)

	Bug_comments(ctx context.Context, obj *bug.Snapshot, input ConnectionInput) (CommentConnection, error)
	Bug_operations(ctx context.Context, obj *bug.Snapshot, input ConnectionInput) (OperationConnection, error)

	CreateOperation_date(ctx context.Context, obj *operations.CreateOperation) (time.Time, error)

	LabelChangeOperation_date(ctx context.Context, obj *operations.LabelChangeOperation) (time.Time, error)

	Query_defaultRepository(ctx context.Context) (*repoResolver, error)
	Query_repository(ctx context.Context, id string) (*repoResolver, error)

	Repository_allBugs(ctx context.Context, obj *repoResolver, input ConnectionInput) (BugConnection, error)
	Repository_bug(ctx context.Context, obj *repoResolver, prefix string) (*bug.Snapshot, error)

	SetStatusOperation_date(ctx context.Context, obj *operations.SetStatusOperation) (time.Time, error)
	SetStatusOperation_status(ctx context.Context, obj *operations.SetStatusOperation) (Status, error)

	SetTitleOperation_date(ctx context.Context, obj *operations.SetTitleOperation) (time.Time, error)
}

type ResolverRoot interface {
	AddCommentOperation() AddCommentOperationResolver
	Bug() BugResolver
	CreateOperation() CreateOperationResolver
	LabelChangeOperation() LabelChangeOperationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	SetStatusOperation() SetStatusOperationResolver
	SetTitleOperation() SetTitleOperationResolver
}
type AddCommentOperationResolver interface {
	Date(ctx context.Context, obj *operations.AddCommentOperation) (time.Time, error)
}
type BugResolver interface {
	Status(ctx context.Context, obj *bug.Snapshot) (Status, error)

	Comments(ctx context.Context, obj *bug.Snapshot, input ConnectionInput) (CommentConnection, error)
	Operations(ctx context.Context, obj *bug.Snapshot, input ConnectionInput) (OperationConnection, error)
}
type CreateOperationResolver interface {
	Date(ctx context.Context, obj *operations.CreateOperation) (time.Time, error)
}
type LabelChangeOperationResolver interface {
	Date(ctx context.Context, obj *operations.LabelChangeOperation) (time.Time, error)
}
type QueryResolver interface {
	DefaultRepository(ctx context.Context) (*repoResolver, error)
	Repository(ctx context.Context, id string) (*repoResolver, error)
}
type RepositoryResolver interface {
	AllBugs(ctx context.Context, obj *repoResolver, input ConnectionInput) (BugConnection, error)
	Bug(ctx context.Context, obj *repoResolver, prefix string) (*bug.Snapshot, error)
}
type SetStatusOperationResolver interface {
	Date(ctx context.Context, obj *operations.SetStatusOperation) (time.Time, error)
	Status(ctx context.Context, obj *operations.SetStatusOperation) (Status, error)
}
type SetTitleOperationResolver interface {
	Date(ctx context.Context, obj *operations.SetTitleOperation) (time.Time, error)
}

type shortMapper struct {
	r ResolverRoot
}

func (s shortMapper) AddCommentOperation_date(ctx context.Context, obj *operations.AddCommentOperation) (time.Time, error) {
	return s.r.AddCommentOperation().Date(ctx, obj)
}

func (s shortMapper) Bug_status(ctx context.Context, obj *bug.Snapshot) (Status, error) {
	return s.r.Bug().Status(ctx, obj)
}

func (s shortMapper) Bug_comments(ctx context.Context, obj *bug.Snapshot, input ConnectionInput) (CommentConnection, error) {
	return s.r.Bug().Comments(ctx, obj, input)
}

func (s shortMapper) Bug_operations(ctx context.Context, obj *bug.Snapshot, input ConnectionInput) (OperationConnection, error) {
	return s.r.Bug().Operations(ctx, obj, input)
}

func (s shortMapper) CreateOperation_date(ctx context.Context, obj *operations.CreateOperation) (time.Time, error) {
	return s.r.CreateOperation().Date(ctx, obj)
}

func (s shortMapper) LabelChangeOperation_date(ctx context.Context, obj *operations.LabelChangeOperation) (time.Time, error) {
	return s.r.LabelChangeOperation().Date(ctx, obj)
}

func (s shortMapper) Query_defaultRepository(ctx context.Context) (*repoResolver, error) {
	return s.r.Query().DefaultRepository(ctx)
}

func (s shortMapper) Query_repository(ctx context.Context, id string) (*repoResolver, error) {
	return s.r.Query().Repository(ctx, id)
}

func (s shortMapper) Repository_allBugs(ctx context.Context, obj *repoResolver, input ConnectionInput) (BugConnection, error) {
	return s.r.Repository().AllBugs(ctx, obj, input)
}

func (s shortMapper) Repository_bug(ctx context.Context, obj *repoResolver, prefix string) (*bug.Snapshot, error) {
	return s.r.Repository().Bug(ctx, obj, prefix)
}

func (s shortMapper) SetStatusOperation_date(ctx context.Context, obj *operations.SetStatusOperation) (time.Time, error) {
	return s.r.SetStatusOperation().Date(ctx, obj)
}

func (s shortMapper) SetStatusOperation_status(ctx context.Context, obj *operations.SetStatusOperation) (Status, error) {
	return s.r.SetStatusOperation().Status(ctx, obj)
}

func (s shortMapper) SetTitleOperation_date(ctx context.Context, obj *operations.SetTitleOperation) (time.Time, error) {
	return s.r.SetTitleOperation().Date(ctx, obj)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	return graphql.ErrorResponse(ctx, "mutations are not supported")
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var addCommentOperationImplementors = []string{"AddCommentOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddCommentOperation(ctx context.Context, sel []query.Selection, obj *operations.AddCommentOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, addCommentOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddCommentOperation")
		case "author":
			out.Values[i] = ec._AddCommentOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._AddCommentOperation_date(ctx, field, obj)
		case "message":
			out.Values[i] = ec._AddCommentOperation_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AddCommentOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AddCommentOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _AddCommentOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.AddCommentOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _AddCommentOperation_message(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AddCommentOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	return graphql.MarshalString(res)
}

var bugImplementors = []string{"Bug"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Bug(ctx context.Context, sel []query.Selection, obj *bug.Snapshot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bugImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bug")
		case "id":
			out.Values[i] = ec._Bug_id(ctx, field, obj)
		case "humanId":
			out.Values[i] = ec._Bug_humanId(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Bug_title(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Bug_status(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._Bug_labels(ctx, field, obj)
		case "comments":
			out.Values[i] = ec._Bug_comments(ctx, field, obj)
		case "operations":
			out.Values[i] = ec._Bug_operations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Bug_id(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Id()
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Bug_humanId(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.HumanId()
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Bug_title(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Title
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Bug_status(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_status(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Status)
		return res
	})
}

func (ec *executionContext) _Bug_labels(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Labels
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _Bug_comments(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 ConnectionInput
	if tmp, ok := field.Args["input"]; ok {
		var err error
		arg0, err = UnmarshalConnectionInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["input"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_comments(ctx, obj, args["input"].(ConnectionInput))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(CommentConnection)
		return ec._CommentConnection(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Bug_operations(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 ConnectionInput
	if tmp, ok := field.Args["input"]; ok {
		var err error
		arg0, err = UnmarshalConnectionInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["input"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_operations(ctx, obj, args["input"].(ConnectionInput))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(OperationConnection)
		return ec._OperationConnection(ctx, field.Selections, &res)
	})
}

var bugConnectionImplementors = []string{"BugConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BugConnection(ctx context.Context, sel []query.Selection, obj *BugConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bugConnectionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BugConnection")
		case "edges":
			out.Values[i] = ec._BugConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._BugConnection_pageInfo(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._BugConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _BugConnection_edges(ctx context.Context, field graphql.CollectedField, obj *BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Edges
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._BugEdge(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _BugConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PageInfo
	return ec._PageInfo(ctx, field.Selections, &res)
}

func (ec *executionContext) _BugConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.TotalCount
	return graphql.MarshalInt(res)
}

var bugEdgeImplementors = []string{"BugEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BugEdge(ctx context.Context, sel []query.Selection, obj *BugEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bugEdgeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BugEdge")
		case "cursor":
			out.Values[i] = ec._BugEdge_cursor(ctx, field, obj)
		case "node":
			out.Values[i] = ec._BugEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _BugEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *BugEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _BugEdge_node(ctx context.Context, field graphql.CollectedField, obj *BugEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Node
	return ec._Bug(ctx, field.Selections, &res)
}

var commentImplementors = []string{"Comment", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Comment(ctx context.Context, sel []query.Selection, obj *bug.Comment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, commentImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Comment")
		case "author":
			out.Values[i] = ec._Comment_author(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Comment_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Comment_author(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Comment"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _Comment_message(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Comment"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	return graphql.MarshalString(res)
}

var commentConnectionImplementors = []string{"CommentConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentConnection(ctx context.Context, sel []query.Selection, obj *CommentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, commentConnectionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentConnection")
		case "edges":
			out.Values[i] = ec._CommentConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._CommentConnection_pageInfo(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CommentConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _CommentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Edges
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._CommentEdge(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _CommentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PageInfo
	return ec._PageInfo(ctx, field.Selections, &res)
}

func (ec *executionContext) _CommentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.TotalCount
	return graphql.MarshalInt(res)
}

var commentEdgeImplementors = []string{"CommentEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentEdge(ctx context.Context, sel []query.Selection, obj *CommentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, commentEdgeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentEdge")
		case "cursor":
			out.Values[i] = ec._CommentEdge_cursor(ctx, field, obj)
		case "node":
			out.Values[i] = ec._CommentEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _CommentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *CommentEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _CommentEdge_node(ctx context.Context, field graphql.CollectedField, obj *CommentEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Node
	return ec._Comment(ctx, field.Selections, &res)
}

var createOperationImplementors = []string{"CreateOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CreateOperation(ctx context.Context, sel []query.Selection, obj *operations.CreateOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, createOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateOperation")
		case "author":
			out.Values[i] = ec._CreateOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._CreateOperation_date(ctx, field, obj)
		case "title":
			out.Values[i] = ec._CreateOperation_title(ctx, field, obj)
		case "message":
			out.Values[i] = ec._CreateOperation_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _CreateOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _CreateOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.CreateOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _CreateOperation_title(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Title
	return graphql.MarshalString(res)
}

func (ec *executionContext) _CreateOperation_message(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	return graphql.MarshalString(res)
}

var labelChangeOperationImplementors = []string{"LabelChangeOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LabelChangeOperation(ctx context.Context, sel []query.Selection, obj *operations.LabelChangeOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, labelChangeOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelChangeOperation")
		case "author":
			out.Values[i] = ec._LabelChangeOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._LabelChangeOperation_date(ctx, field, obj)
		case "added":
			out.Values[i] = ec._LabelChangeOperation_added(ctx, field, obj)
		case "removed":
			out.Values[i] = ec._LabelChangeOperation_removed(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _LabelChangeOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "LabelChangeOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _LabelChangeOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.LabelChangeOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _LabelChangeOperation_added(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "LabelChangeOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Added
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _LabelChangeOperation_removed(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "LabelChangeOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Removed
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

var operationConnectionImplementors = []string{"OperationConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OperationConnection(ctx context.Context, sel []query.Selection, obj *OperationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, operationConnectionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationConnection")
		case "edges":
			out.Values[i] = ec._OperationConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._OperationConnection_pageInfo(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._OperationConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OperationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Edges
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._OperationEdge(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _OperationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PageInfo
	return ec._PageInfo(ctx, field.Selections, &res)
}

func (ec *executionContext) _OperationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.TotalCount
	return graphql.MarshalInt(res)
}

var operationEdgeImplementors = []string{"OperationEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OperationEdge(ctx context.Context, sel []query.Selection, obj *OperationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, operationEdgeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationEdge")
		case "cursor":
			out.Values[i] = ec._OperationEdge_cursor(ctx, field, obj)
		case "node":
			out.Values[i] = ec._OperationEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OperationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *OperationEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _OperationEdge_node(ctx context.Context, field graphql.CollectedField, obj *OperationEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Node
	return ec._OperationUnion(ctx, field.Selections, &res)
}

var pageInfoImplementors = []string{"PageInfo"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PageInfo(ctx context.Context, sel []query.Selection, obj *PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, pageInfoImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *PageInfo) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PageInfo"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.HasNextPage
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *PageInfo) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PageInfo"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.HasPreviousPage
	return graphql.MarshalBoolean(res)
}

var personImplementors = []string{"Person"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Person(ctx context.Context, sel []query.Selection, obj *bug.Person) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, personImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Person")
		case "email":
			out.Values[i] = ec._Person_email(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Person_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Person_email(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Email
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_name(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "defaultRepository":
			out.Values[i] = ec._Query_defaultRepository(ctx, field)
		case "repository":
			out.Values[i] = ec._Query_repository(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_defaultRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_defaultRepository(ctx)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*repoResolver)
		if res == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query_repository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["id"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_repository(ctx, args["id"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*repoResolver)
		if res == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var repositoryImplementors = []string{"Repository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Repository(ctx context.Context, sel []query.Selection, obj *repoResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, repositoryImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "allBugs":
			out.Values[i] = ec._Repository_allBugs(ctx, field, obj)
		case "bug":
			out.Values[i] = ec._Repository_bug(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Repository_allBugs(ctx context.Context, field graphql.CollectedField, obj *repoResolver) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 ConnectionInput
	if tmp, ok := field.Args["input"]; ok {
		var err error
		arg0, err = UnmarshalConnectionInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["input"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_allBugs(ctx, obj, args["input"].(ConnectionInput))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(BugConnection)
		return ec._BugConnection(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Repository_bug(ctx context.Context, field graphql.CollectedField, obj *repoResolver) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_bug(ctx, obj, args["prefix"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*bug.Snapshot)
		if res == nil {
			return graphql.Null
		}
		return ec._Bug(ctx, field.Selections, res)
	})
}

var setStatusOperationImplementors = []string{"SetStatusOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetStatusOperation(ctx context.Context, sel []query.Selection, obj *operations.SetStatusOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, setStatusOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetStatusOperation")
		case "author":
			out.Values[i] = ec._SetStatusOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._SetStatusOperation_date(ctx, field, obj)
		case "status":
			out.Values[i] = ec._SetStatusOperation_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SetStatusOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.SetStatusOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetStatusOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _SetStatusOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.SetStatusOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SetStatusOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _SetStatusOperation_status(ctx context.Context, field graphql.CollectedField, obj *operations.SetStatusOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SetStatusOperation_status(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Status)
		return res
	})
}

var setTitleOperationImplementors = []string{"SetTitleOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetTitleOperation(ctx context.Context, sel []query.Selection, obj *operations.SetTitleOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, setTitleOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetTitleOperation")
		case "author":
			out.Values[i] = ec._SetTitleOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._SetTitleOperation_date(ctx, field, obj)
		case "title":
			out.Values[i] = ec._SetTitleOperation_title(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SetTitleOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetTitleOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _SetTitleOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SetTitleOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _SetTitleOperation_title(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetTitleOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Title
	return graphql.MarshalString(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Authored(ctx context.Context, sel []query.Selection, obj *Authored) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case bug.Comment:
		return ec._Comment(ctx, sel, &obj)
	case *bug.Comment:
		return ec._Comment(ctx, sel, obj)
	case operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, &obj)
	case *operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, &obj)
	case *operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, &obj)
	case *operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, &obj)
	case *operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, &obj)
	case *operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Operation(ctx context.Context, sel []query.Selection, obj *Operation) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, &obj)
	case *operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, &obj)
	case *operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, &obj)
	case *operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, &obj)
	case *operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, &obj)
	case *operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _OperationUnion(ctx context.Context, sel []query.Selection, obj *OperationUnion) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, &obj)
	case *operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, &obj)
	case *operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, &obj)
	case *operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, &obj)
	case *operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, &obj)
	case *operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalConnectionInput(v interface{}) (ConnectionInput, error) {
	var it ConnectionInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "after":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.After = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "before":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Before = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.First = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "last":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Last = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`scalar Time
scalar Label

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
#  startCursor: String

  # When paginating forwards, the cursor to continue.
#  endCursor: String
}

input ConnectionInput {
  # Returns the elements in the list that come after the specified cursor.
  after: String

  # Returns the elements in the list that come before the specified cursor.
  before: String

  # Returns the first _n_ elements from the list.
  first: Int

  # Returns the last _n_ elements from the list.
  last: Int
}

# Represents an person in a git object.
type Person {
  # The email of the person.
  email: String

  # The name of the person.
  name: String
}


type CommentConnection {
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

# Represents a comment on a bug.
type Comment implements Authored {
  # The author of this comment.
  author: Person!

  # The message of this comment.
  message: String!
}

enum Status {
  OPEN
  CLOSED
}

# An object that has an author.
interface Authored {
  # The author of this object.
  author: Person!
}

type OperationConnection {
  edges: [OperationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OperationEdge {
  cursor: String!
  node: OperationUnion!
}

# An operation applied to a bug.
interface Operation {
  # The operations author.
  author: Person!

  # The datetime when this operation was issued.
  date: Time!
}

type CreateOperation implements Operation, Authored {
  author: Person!
  date: Time!

  title: String!
  message: String!
}

type SetTitleOperation implements Operation, Authored {
  author: Person!
  date: Time!

  title: String!
}

type AddCommentOperation implements Operation, Authored {
  author: Person!
  date: Time!

  message: String!
}

type SetStatusOperation implements Operation, Authored {
  author: Person!
  date: Time!

  status: Status!
}

type LabelChangeOperation implements Operation, Authored {
  author: Person!
  date: Time!

  added: [Label!]!
  removed: [Label!]!
}

union OperationUnion =
    CreateOperation
  | SetTitleOperation
  | AddCommentOperation
  | SetStatusOperation
  | LabelChangeOperation

# The connection type for Bug.
type BugConnection {
  # A list of edges.
  edges: [BugEdge]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Identifies the total count of items in the connection.
  totalCount: Int!
}

# An edge in a connection.
type BugEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Bug!
}

type Bug {
  id: String!
  humanId: String!
  title: String!
  status: Status!

  # A list of labels associated with the repository.
  labels: [Label!]!

  comments(input: ConnectionInput!): CommentConnection!

  operations(input: ConnectionInput!): OperationConnection!
}

type Repository {
  allBugs(input: ConnectionInput!): BugConnection!
  bug(prefix: String!): Bug
}

type Query {
  defaultRepository: Repository
  repository(id: String!): Repository
}
`)
