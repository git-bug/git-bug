// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"
	sync "sync"
	time "time"

	graphql "github.com/99designs/gqlgen/graphql"
	introspection "github.com/99designs/gqlgen/graphql/introspection"
	bug "github.com/MichaelMure/git-bug/bug"
	models "github.com/MichaelMure/git-bug/graphql/models"
	git "github.com/MichaelMure/git-bug/util/git"
	gqlparser "github.com/vektah/gqlparser"
	ast "github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AddCommentOperation() AddCommentOperationResolver
	AddCommentTimelineItem() AddCommentTimelineItemResolver
	Bug() BugResolver
	CommentHistoryStep() CommentHistoryStepResolver
	CreateOperation() CreateOperationResolver
	CreateTimelineItem() CreateTimelineItemResolver
	EditCommentOperation() EditCommentOperationResolver
	LabelChangeOperation() LabelChangeOperationResolver
	LabelChangeTimelineItem() LabelChangeTimelineItemResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	SetStatusOperation() SetStatusOperationResolver
	SetStatusTimelineItem() SetStatusTimelineItemResolver
	SetTitleOperation() SetTitleOperationResolver
	SetTitleTimelineItem() SetTitleTimelineItemResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AddCommentOperation struct {
		Hash    func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Message func(childComplexity int) int
		Files   func(childComplexity int) int
	}

	AddCommentTimelineItem struct {
		Hash      func(childComplexity int) int
		Author    func(childComplexity int) int
		Message   func(childComplexity int) int
		Files     func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		LastEdit  func(childComplexity int) int
		Edited    func(childComplexity int) int
		History   func(childComplexity int) int
	}

	Bug struct {
		Id         func(childComplexity int) int
		HumanId    func(childComplexity int) int
		Status     func(childComplexity int) int
		Title      func(childComplexity int) int
		Labels     func(childComplexity int) int
		Author     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		LastEdit   func(childComplexity int) int
		Comments   func(childComplexity int, after *string, before *string, first *int, last *int) int
		Timeline   func(childComplexity int, after *string, before *string, first *int, last *int) int
		Operations func(childComplexity int, after *string, before *string, first *int, last *int) int
	}

	BugConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BugEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Comment struct {
		Author  func(childComplexity int) int
		Message func(childComplexity int) int
		Files   func(childComplexity int) int
	}

	CommentConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CommentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CommentHistoryStep struct {
		Message func(childComplexity int) int
		Date    func(childComplexity int) int
	}

	CreateOperation struct {
		Hash    func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Title   func(childComplexity int) int
		Message func(childComplexity int) int
		Files   func(childComplexity int) int
	}

	CreateTimelineItem struct {
		Hash      func(childComplexity int) int
		Author    func(childComplexity int) int
		Message   func(childComplexity int) int
		Files     func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		LastEdit  func(childComplexity int) int
		Edited    func(childComplexity int) int
		History   func(childComplexity int) int
	}

	EditCommentOperation struct {
		Hash    func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Target  func(childComplexity int) int
		Message func(childComplexity int) int
		Files   func(childComplexity int) int
	}

	LabelChangeOperation struct {
		Hash    func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Added   func(childComplexity int) int
		Removed func(childComplexity int) int
	}

	LabelChangeTimelineItem struct {
		Hash    func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Added   func(childComplexity int) int
		Removed func(childComplexity int) int
	}

	Mutation struct {
		NewBug       func(childComplexity int, repoRef *string, title string, message string, files []git.Hash) int
		AddComment   func(childComplexity int, repoRef *string, prefix string, message string, files []git.Hash) int
		ChangeLabels func(childComplexity int, repoRef *string, prefix string, added []string, removed []string) int
		Open         func(childComplexity int, repoRef *string, prefix string) int
		Close        func(childComplexity int, repoRef *string, prefix string) int
		SetTitle     func(childComplexity int, repoRef *string, prefix string, title string) int
		Commit       func(childComplexity int, repoRef *string, prefix string) int
	}

	OperationConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OperationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
		EndCursor       func(childComplexity int) int
	}

	Person struct {
		Email     func(childComplexity int) int
		Name      func(childComplexity int) int
		AvatarUrl func(childComplexity int) int
	}

	Query struct {
		DefaultRepository func(childComplexity int) int
		Repository        func(childComplexity int, id string) int
	}

	Repository struct {
		AllBugs func(childComplexity int, after *string, before *string, first *int, last *int, query *string) int
		Bug     func(childComplexity int, prefix string) int
	}

	SetStatusOperation struct {
		Hash   func(childComplexity int) int
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	SetStatusTimelineItem struct {
		Hash   func(childComplexity int) int
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	SetTitleOperation struct {
		Hash   func(childComplexity int) int
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		Title  func(childComplexity int) int
		Was    func(childComplexity int) int
	}

	SetTitleTimelineItem struct {
		Hash   func(childComplexity int) int
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		Title  func(childComplexity int) int
		Was    func(childComplexity int) int
	}

	TimelineItemConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TimelineItemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type AddCommentOperationResolver interface {
	Date(ctx context.Context, obj *bug.AddCommentOperation) (time.Time, error)
}
type AddCommentTimelineItemResolver interface {
	CreatedAt(ctx context.Context, obj *bug.AddCommentTimelineItem) (time.Time, error)
	LastEdit(ctx context.Context, obj *bug.AddCommentTimelineItem) (time.Time, error)
}
type BugResolver interface {
	Status(ctx context.Context, obj *bug.Snapshot) (models.Status, error)

	LastEdit(ctx context.Context, obj *bug.Snapshot) (time.Time, error)
	Comments(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.CommentConnection, error)
	Timeline(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.TimelineItemConnection, error)
	Operations(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.OperationConnection, error)
}
type CommentHistoryStepResolver interface {
	Date(ctx context.Context, obj *bug.CommentHistoryStep) (time.Time, error)
}
type CreateOperationResolver interface {
	Date(ctx context.Context, obj *bug.CreateOperation) (time.Time, error)
}
type CreateTimelineItemResolver interface {
	CreatedAt(ctx context.Context, obj *bug.CreateTimelineItem) (time.Time, error)
	LastEdit(ctx context.Context, obj *bug.CreateTimelineItem) (time.Time, error)
}
type EditCommentOperationResolver interface {
	Date(ctx context.Context, obj *bug.EditCommentOperation) (time.Time, error)
}
type LabelChangeOperationResolver interface {
	Date(ctx context.Context, obj *bug.LabelChangeOperation) (time.Time, error)
}
type LabelChangeTimelineItemResolver interface {
	Date(ctx context.Context, obj *bug.LabelChangeTimelineItem) (time.Time, error)
}
type MutationResolver interface {
	NewBug(ctx context.Context, repoRef *string, title string, message string, files []git.Hash) (bug.Snapshot, error)
	AddComment(ctx context.Context, repoRef *string, prefix string, message string, files []git.Hash) (bug.Snapshot, error)
	ChangeLabels(ctx context.Context, repoRef *string, prefix string, added []string, removed []string) (bug.Snapshot, error)
	Open(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
	Close(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
	SetTitle(ctx context.Context, repoRef *string, prefix string, title string) (bug.Snapshot, error)
	Commit(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
}
type QueryResolver interface {
	DefaultRepository(ctx context.Context) (*models.Repository, error)
	Repository(ctx context.Context, id string) (*models.Repository, error)
}
type RepositoryResolver interface {
	AllBugs(ctx context.Context, obj *models.Repository, after *string, before *string, first *int, last *int, query *string) (models.BugConnection, error)
	Bug(ctx context.Context, obj *models.Repository, prefix string) (*bug.Snapshot, error)
}
type SetStatusOperationResolver interface {
	Date(ctx context.Context, obj *bug.SetStatusOperation) (time.Time, error)
	Status(ctx context.Context, obj *bug.SetStatusOperation) (models.Status, error)
}
type SetStatusTimelineItemResolver interface {
	Date(ctx context.Context, obj *bug.SetStatusTimelineItem) (time.Time, error)
	Status(ctx context.Context, obj *bug.SetStatusTimelineItem) (models.Status, error)
}
type SetTitleOperationResolver interface {
	Date(ctx context.Context, obj *bug.SetTitleOperation) (time.Time, error)
}
type SetTitleTimelineItemResolver interface {
	Date(ctx context.Context, obj *bug.SetTitleTimelineItem) (time.Time, error)
}

func field_Bug_comments_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil

}

func field_Bug_timeline_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil

}

func field_Bug_operations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil

}

func field_Mutation_newBug_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["title"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["title"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["message"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["message"] = arg2
	var arg3 []git.Hash
	if tmp, ok := rawArgs["files"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]git.Hash, len(rawIf1))
		for idx1 := range rawIf1 {
			err = (&arg3[idx1]).UnmarshalGQL(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["files"] = arg3
	return args, nil

}

func field_Mutation_addComment_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["message"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["message"] = arg2
	var arg3 []git.Hash
	if tmp, ok := rawArgs["files"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]git.Hash, len(rawIf1))
		for idx1 := range rawIf1 {
			err = (&arg3[idx1]).UnmarshalGQL(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["files"] = arg3
	return args, nil

}

func field_Mutation_changeLabels_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["added"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["added"] = arg2
	var arg3 []string
	if tmp, ok := rawArgs["removed"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg3[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["removed"] = arg3
	return args, nil

}

func field_Mutation_open_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg1
	return args, nil

}

func field_Mutation_close_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg1
	return args, nil

}

func field_Mutation_setTitle_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["title"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["title"] = arg2
	return args, nil

}

func field_Mutation_commit_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg1
	return args, nil

}

func field_Query_repository_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Repository_allBugs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["query"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg4
	return args, nil

}

func field_Repository_bug_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["prefix"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prefix"] = arg0
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "AddCommentOperation.hash":
		if e.complexity.AddCommentOperation.Hash == nil {
			break
		}

		return e.complexity.AddCommentOperation.Hash(childComplexity), true

	case "AddCommentOperation.author":
		if e.complexity.AddCommentOperation.Author == nil {
			break
		}

		return e.complexity.AddCommentOperation.Author(childComplexity), true

	case "AddCommentOperation.date":
		if e.complexity.AddCommentOperation.Date == nil {
			break
		}

		return e.complexity.AddCommentOperation.Date(childComplexity), true

	case "AddCommentOperation.message":
		if e.complexity.AddCommentOperation.Message == nil {
			break
		}

		return e.complexity.AddCommentOperation.Message(childComplexity), true

	case "AddCommentOperation.files":
		if e.complexity.AddCommentOperation.Files == nil {
			break
		}

		return e.complexity.AddCommentOperation.Files(childComplexity), true

	case "AddCommentTimelineItem.hash":
		if e.complexity.AddCommentTimelineItem.Hash == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Hash(childComplexity), true

	case "AddCommentTimelineItem.author":
		if e.complexity.AddCommentTimelineItem.Author == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Author(childComplexity), true

	case "AddCommentTimelineItem.message":
		if e.complexity.AddCommentTimelineItem.Message == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Message(childComplexity), true

	case "AddCommentTimelineItem.files":
		if e.complexity.AddCommentTimelineItem.Files == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Files(childComplexity), true

	case "AddCommentTimelineItem.createdAt":
		if e.complexity.AddCommentTimelineItem.CreatedAt == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.CreatedAt(childComplexity), true

	case "AddCommentTimelineItem.lastEdit":
		if e.complexity.AddCommentTimelineItem.LastEdit == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.LastEdit(childComplexity), true

	case "AddCommentTimelineItem.edited":
		if e.complexity.AddCommentTimelineItem.Edited == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Edited(childComplexity), true

	case "AddCommentTimelineItem.history":
		if e.complexity.AddCommentTimelineItem.History == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.History(childComplexity), true

	case "Bug.id":
		if e.complexity.Bug.Id == nil {
			break
		}

		return e.complexity.Bug.Id(childComplexity), true

	case "Bug.humanId":
		if e.complexity.Bug.HumanId == nil {
			break
		}

		return e.complexity.Bug.HumanId(childComplexity), true

	case "Bug.status":
		if e.complexity.Bug.Status == nil {
			break
		}

		return e.complexity.Bug.Status(childComplexity), true

	case "Bug.title":
		if e.complexity.Bug.Title == nil {
			break
		}

		return e.complexity.Bug.Title(childComplexity), true

	case "Bug.labels":
		if e.complexity.Bug.Labels == nil {
			break
		}

		return e.complexity.Bug.Labels(childComplexity), true

	case "Bug.author":
		if e.complexity.Bug.Author == nil {
			break
		}

		return e.complexity.Bug.Author(childComplexity), true

	case "Bug.createdAt":
		if e.complexity.Bug.CreatedAt == nil {
			break
		}

		return e.complexity.Bug.CreatedAt(childComplexity), true

	case "Bug.lastEdit":
		if e.complexity.Bug.LastEdit == nil {
			break
		}

		return e.complexity.Bug.LastEdit(childComplexity), true

	case "Bug.comments":
		if e.complexity.Bug.Comments == nil {
			break
		}

		args, err := field_Bug_comments_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Comments(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.timeline":
		if e.complexity.Bug.Timeline == nil {
			break
		}

		args, err := field_Bug_timeline_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Timeline(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.operations":
		if e.complexity.Bug.Operations == nil {
			break
		}

		args, err := field_Bug_operations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Operations(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "BugConnection.edges":
		if e.complexity.BugConnection.Edges == nil {
			break
		}

		return e.complexity.BugConnection.Edges(childComplexity), true

	case "BugConnection.nodes":
		if e.complexity.BugConnection.Nodes == nil {
			break
		}

		return e.complexity.BugConnection.Nodes(childComplexity), true

	case "BugConnection.pageInfo":
		if e.complexity.BugConnection.PageInfo == nil {
			break
		}

		return e.complexity.BugConnection.PageInfo(childComplexity), true

	case "BugConnection.totalCount":
		if e.complexity.BugConnection.TotalCount == nil {
			break
		}

		return e.complexity.BugConnection.TotalCount(childComplexity), true

	case "BugEdge.cursor":
		if e.complexity.BugEdge.Cursor == nil {
			break
		}

		return e.complexity.BugEdge.Cursor(childComplexity), true

	case "BugEdge.node":
		if e.complexity.BugEdge.Node == nil {
			break
		}

		return e.complexity.BugEdge.Node(childComplexity), true

	case "Comment.author":
		if e.complexity.Comment.Author == nil {
			break
		}

		return e.complexity.Comment.Author(childComplexity), true

	case "Comment.message":
		if e.complexity.Comment.Message == nil {
			break
		}

		return e.complexity.Comment.Message(childComplexity), true

	case "Comment.files":
		if e.complexity.Comment.Files == nil {
			break
		}

		return e.complexity.Comment.Files(childComplexity), true

	case "CommentConnection.edges":
		if e.complexity.CommentConnection.Edges == nil {
			break
		}

		return e.complexity.CommentConnection.Edges(childComplexity), true

	case "CommentConnection.nodes":
		if e.complexity.CommentConnection.Nodes == nil {
			break
		}

		return e.complexity.CommentConnection.Nodes(childComplexity), true

	case "CommentConnection.pageInfo":
		if e.complexity.CommentConnection.PageInfo == nil {
			break
		}

		return e.complexity.CommentConnection.PageInfo(childComplexity), true

	case "CommentConnection.totalCount":
		if e.complexity.CommentConnection.TotalCount == nil {
			break
		}

		return e.complexity.CommentConnection.TotalCount(childComplexity), true

	case "CommentEdge.cursor":
		if e.complexity.CommentEdge.Cursor == nil {
			break
		}

		return e.complexity.CommentEdge.Cursor(childComplexity), true

	case "CommentEdge.node":
		if e.complexity.CommentEdge.Node == nil {
			break
		}

		return e.complexity.CommentEdge.Node(childComplexity), true

	case "CommentHistoryStep.message":
		if e.complexity.CommentHistoryStep.Message == nil {
			break
		}

		return e.complexity.CommentHistoryStep.Message(childComplexity), true

	case "CommentHistoryStep.date":
		if e.complexity.CommentHistoryStep.Date == nil {
			break
		}

		return e.complexity.CommentHistoryStep.Date(childComplexity), true

	case "CreateOperation.hash":
		if e.complexity.CreateOperation.Hash == nil {
			break
		}

		return e.complexity.CreateOperation.Hash(childComplexity), true

	case "CreateOperation.author":
		if e.complexity.CreateOperation.Author == nil {
			break
		}

		return e.complexity.CreateOperation.Author(childComplexity), true

	case "CreateOperation.date":
		if e.complexity.CreateOperation.Date == nil {
			break
		}

		return e.complexity.CreateOperation.Date(childComplexity), true

	case "CreateOperation.title":
		if e.complexity.CreateOperation.Title == nil {
			break
		}

		return e.complexity.CreateOperation.Title(childComplexity), true

	case "CreateOperation.message":
		if e.complexity.CreateOperation.Message == nil {
			break
		}

		return e.complexity.CreateOperation.Message(childComplexity), true

	case "CreateOperation.files":
		if e.complexity.CreateOperation.Files == nil {
			break
		}

		return e.complexity.CreateOperation.Files(childComplexity), true

	case "CreateTimelineItem.hash":
		if e.complexity.CreateTimelineItem.Hash == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Hash(childComplexity), true

	case "CreateTimelineItem.author":
		if e.complexity.CreateTimelineItem.Author == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Author(childComplexity), true

	case "CreateTimelineItem.message":
		if e.complexity.CreateTimelineItem.Message == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Message(childComplexity), true

	case "CreateTimelineItem.files":
		if e.complexity.CreateTimelineItem.Files == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Files(childComplexity), true

	case "CreateTimelineItem.createdAt":
		if e.complexity.CreateTimelineItem.CreatedAt == nil {
			break
		}

		return e.complexity.CreateTimelineItem.CreatedAt(childComplexity), true

	case "CreateTimelineItem.lastEdit":
		if e.complexity.CreateTimelineItem.LastEdit == nil {
			break
		}

		return e.complexity.CreateTimelineItem.LastEdit(childComplexity), true

	case "CreateTimelineItem.edited":
		if e.complexity.CreateTimelineItem.Edited == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Edited(childComplexity), true

	case "CreateTimelineItem.history":
		if e.complexity.CreateTimelineItem.History == nil {
			break
		}

		return e.complexity.CreateTimelineItem.History(childComplexity), true

	case "EditCommentOperation.hash":
		if e.complexity.EditCommentOperation.Hash == nil {
			break
		}

		return e.complexity.EditCommentOperation.Hash(childComplexity), true

	case "EditCommentOperation.author":
		if e.complexity.EditCommentOperation.Author == nil {
			break
		}

		return e.complexity.EditCommentOperation.Author(childComplexity), true

	case "EditCommentOperation.date":
		if e.complexity.EditCommentOperation.Date == nil {
			break
		}

		return e.complexity.EditCommentOperation.Date(childComplexity), true

	case "EditCommentOperation.target":
		if e.complexity.EditCommentOperation.Target == nil {
			break
		}

		return e.complexity.EditCommentOperation.Target(childComplexity), true

	case "EditCommentOperation.message":
		if e.complexity.EditCommentOperation.Message == nil {
			break
		}

		return e.complexity.EditCommentOperation.Message(childComplexity), true

	case "EditCommentOperation.files":
		if e.complexity.EditCommentOperation.Files == nil {
			break
		}

		return e.complexity.EditCommentOperation.Files(childComplexity), true

	case "LabelChangeOperation.hash":
		if e.complexity.LabelChangeOperation.Hash == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Hash(childComplexity), true

	case "LabelChangeOperation.author":
		if e.complexity.LabelChangeOperation.Author == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Author(childComplexity), true

	case "LabelChangeOperation.date":
		if e.complexity.LabelChangeOperation.Date == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Date(childComplexity), true

	case "LabelChangeOperation.added":
		if e.complexity.LabelChangeOperation.Added == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Added(childComplexity), true

	case "LabelChangeOperation.removed":
		if e.complexity.LabelChangeOperation.Removed == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Removed(childComplexity), true

	case "LabelChangeTimelineItem.hash":
		if e.complexity.LabelChangeTimelineItem.Hash == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Hash(childComplexity), true

	case "LabelChangeTimelineItem.author":
		if e.complexity.LabelChangeTimelineItem.Author == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Author(childComplexity), true

	case "LabelChangeTimelineItem.date":
		if e.complexity.LabelChangeTimelineItem.Date == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Date(childComplexity), true

	case "LabelChangeTimelineItem.added":
		if e.complexity.LabelChangeTimelineItem.Added == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Added(childComplexity), true

	case "LabelChangeTimelineItem.removed":
		if e.complexity.LabelChangeTimelineItem.Removed == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Removed(childComplexity), true

	case "Mutation.newBug":
		if e.complexity.Mutation.NewBug == nil {
			break
		}

		args, err := field_Mutation_newBug_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewBug(childComplexity, args["repoRef"].(*string), args["title"].(string), args["message"].(string), args["files"].([]git.Hash)), true

	case "Mutation.addComment":
		if e.complexity.Mutation.AddComment == nil {
			break
		}

		args, err := field_Mutation_addComment_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddComment(childComplexity, args["repoRef"].(*string), args["prefix"].(string), args["message"].(string), args["files"].([]git.Hash)), true

	case "Mutation.changeLabels":
		if e.complexity.Mutation.ChangeLabels == nil {
			break
		}

		args, err := field_Mutation_changeLabels_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangeLabels(childComplexity, args["repoRef"].(*string), args["prefix"].(string), args["added"].([]string), args["removed"].([]string)), true

	case "Mutation.open":
		if e.complexity.Mutation.Open == nil {
			break
		}

		args, err := field_Mutation_open_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Open(childComplexity, args["repoRef"].(*string), args["prefix"].(string)), true

	case "Mutation.close":
		if e.complexity.Mutation.Close == nil {
			break
		}

		args, err := field_Mutation_close_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Close(childComplexity, args["repoRef"].(*string), args["prefix"].(string)), true

	case "Mutation.setTitle":
		if e.complexity.Mutation.SetTitle == nil {
			break
		}

		args, err := field_Mutation_setTitle_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTitle(childComplexity, args["repoRef"].(*string), args["prefix"].(string), args["title"].(string)), true

	case "Mutation.commit":
		if e.complexity.Mutation.Commit == nil {
			break
		}

		args, err := field_Mutation_commit_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Commit(childComplexity, args["repoRef"].(*string), args["prefix"].(string)), true

	case "OperationConnection.edges":
		if e.complexity.OperationConnection.Edges == nil {
			break
		}

		return e.complexity.OperationConnection.Edges(childComplexity), true

	case "OperationConnection.nodes":
		if e.complexity.OperationConnection.Nodes == nil {
			break
		}

		return e.complexity.OperationConnection.Nodes(childComplexity), true

	case "OperationConnection.pageInfo":
		if e.complexity.OperationConnection.PageInfo == nil {
			break
		}

		return e.complexity.OperationConnection.PageInfo(childComplexity), true

	case "OperationConnection.totalCount":
		if e.complexity.OperationConnection.TotalCount == nil {
			break
		}

		return e.complexity.OperationConnection.TotalCount(childComplexity), true

	case "OperationEdge.cursor":
		if e.complexity.OperationEdge.Cursor == nil {
			break
		}

		return e.complexity.OperationEdge.Cursor(childComplexity), true

	case "OperationEdge.node":
		if e.complexity.OperationEdge.Node == nil {
			break
		}

		return e.complexity.OperationEdge.Node(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "Person.email":
		if e.complexity.Person.Email == nil {
			break
		}

		return e.complexity.Person.Email(childComplexity), true

	case "Person.name":
		if e.complexity.Person.Name == nil {
			break
		}

		return e.complexity.Person.Name(childComplexity), true

	case "Person.avatarUrl":
		if e.complexity.Person.AvatarUrl == nil {
			break
		}

		return e.complexity.Person.AvatarUrl(childComplexity), true

	case "Query.defaultRepository":
		if e.complexity.Query.DefaultRepository == nil {
			break
		}

		return e.complexity.Query.DefaultRepository(childComplexity), true

	case "Query.repository":
		if e.complexity.Query.Repository == nil {
			break
		}

		args, err := field_Query_repository_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repository(childComplexity, args["id"].(string)), true

	case "Repository.allBugs":
		if e.complexity.Repository.AllBugs == nil {
			break
		}

		args, err := field_Repository_allBugs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.AllBugs(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int), args["query"].(*string)), true

	case "Repository.bug":
		if e.complexity.Repository.Bug == nil {
			break
		}

		args, err := field_Repository_bug_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Bug(childComplexity, args["prefix"].(string)), true

	case "SetStatusOperation.hash":
		if e.complexity.SetStatusOperation.Hash == nil {
			break
		}

		return e.complexity.SetStatusOperation.Hash(childComplexity), true

	case "SetStatusOperation.author":
		if e.complexity.SetStatusOperation.Author == nil {
			break
		}

		return e.complexity.SetStatusOperation.Author(childComplexity), true

	case "SetStatusOperation.date":
		if e.complexity.SetStatusOperation.Date == nil {
			break
		}

		return e.complexity.SetStatusOperation.Date(childComplexity), true

	case "SetStatusOperation.status":
		if e.complexity.SetStatusOperation.Status == nil {
			break
		}

		return e.complexity.SetStatusOperation.Status(childComplexity), true

	case "SetStatusTimelineItem.hash":
		if e.complexity.SetStatusTimelineItem.Hash == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Hash(childComplexity), true

	case "SetStatusTimelineItem.author":
		if e.complexity.SetStatusTimelineItem.Author == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Author(childComplexity), true

	case "SetStatusTimelineItem.date":
		if e.complexity.SetStatusTimelineItem.Date == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Date(childComplexity), true

	case "SetStatusTimelineItem.status":
		if e.complexity.SetStatusTimelineItem.Status == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Status(childComplexity), true

	case "SetTitleOperation.hash":
		if e.complexity.SetTitleOperation.Hash == nil {
			break
		}

		return e.complexity.SetTitleOperation.Hash(childComplexity), true

	case "SetTitleOperation.author":
		if e.complexity.SetTitleOperation.Author == nil {
			break
		}

		return e.complexity.SetTitleOperation.Author(childComplexity), true

	case "SetTitleOperation.date":
		if e.complexity.SetTitleOperation.Date == nil {
			break
		}

		return e.complexity.SetTitleOperation.Date(childComplexity), true

	case "SetTitleOperation.title":
		if e.complexity.SetTitleOperation.Title == nil {
			break
		}

		return e.complexity.SetTitleOperation.Title(childComplexity), true

	case "SetTitleOperation.was":
		if e.complexity.SetTitleOperation.Was == nil {
			break
		}

		return e.complexity.SetTitleOperation.Was(childComplexity), true

	case "SetTitleTimelineItem.hash":
		if e.complexity.SetTitleTimelineItem.Hash == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Hash(childComplexity), true

	case "SetTitleTimelineItem.author":
		if e.complexity.SetTitleTimelineItem.Author == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Author(childComplexity), true

	case "SetTitleTimelineItem.date":
		if e.complexity.SetTitleTimelineItem.Date == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Date(childComplexity), true

	case "SetTitleTimelineItem.title":
		if e.complexity.SetTitleTimelineItem.Title == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Title(childComplexity), true

	case "SetTitleTimelineItem.was":
		if e.complexity.SetTitleTimelineItem.Was == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Was(childComplexity), true

	case "TimelineItemConnection.edges":
		if e.complexity.TimelineItemConnection.Edges == nil {
			break
		}

		return e.complexity.TimelineItemConnection.Edges(childComplexity), true

	case "TimelineItemConnection.nodes":
		if e.complexity.TimelineItemConnection.Nodes == nil {
			break
		}

		return e.complexity.TimelineItemConnection.Nodes(childComplexity), true

	case "TimelineItemConnection.pageInfo":
		if e.complexity.TimelineItemConnection.PageInfo == nil {
			break
		}

		return e.complexity.TimelineItemConnection.PageInfo(childComplexity), true

	case "TimelineItemConnection.totalCount":
		if e.complexity.TimelineItemConnection.TotalCount == nil {
			break
		}

		return e.complexity.TimelineItemConnection.TotalCount(childComplexity), true

	case "TimelineItemEdge.cursor":
		if e.complexity.TimelineItemEdge.Cursor == nil {
			break
		}

		return e.complexity.TimelineItemEdge.Cursor(childComplexity), true

	case "TimelineItemEdge.node":
		if e.complexity.TimelineItemEdge.Node == nil {
			break
		}

		return e.complexity.TimelineItemEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var addCommentOperationImplementors = []string{"AddCommentOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddCommentOperation(ctx context.Context, sel ast.SelectionSet, obj *bug.AddCommentOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addCommentOperationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddCommentOperation")
		case "hash":
			out.Values[i] = ec._AddCommentOperation_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._AddCommentOperation_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._AddCommentOperation_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "message":
			out.Values[i] = ec._AddCommentOperation_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			out.Values[i] = ec._AddCommentOperation_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentOperation_hash(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash()
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentOperation_author(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentOperation_date(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.AddCommentOperation().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentOperation_message(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentOperation_files(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Files, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]git.Hash)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

var addCommentTimelineItemImplementors = []string{"AddCommentTimelineItem", "TimelineItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddCommentTimelineItem(ctx context.Context, sel ast.SelectionSet, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addCommentTimelineItemImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddCommentTimelineItem")
		case "hash":
			out.Values[i] = ec._AddCommentTimelineItem_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._AddCommentTimelineItem_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._AddCommentTimelineItem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			out.Values[i] = ec._AddCommentTimelineItem_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._AddCommentTimelineItem_createdAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "lastEdit":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._AddCommentTimelineItem_lastEdit(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "edited":
			out.Values[i] = ec._AddCommentTimelineItem_edited(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "history":
			out.Values[i] = ec._AddCommentTimelineItem_history(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_hash(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_author(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_message(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_files(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Files, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]git.Hash)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_createdAt(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.AddCommentTimelineItem().CreatedAt(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_lastEdit(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.AddCommentTimelineItem().LastEdit(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_edited(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Edited(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddCommentTimelineItem_history(ctx context.Context, field graphql.CollectedField, obj *bug.AddCommentTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AddCommentTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.History, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.CommentHistoryStep)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._CommentHistoryStep(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var bugImplementors = []string{"Bug"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Bug(ctx context.Context, sel ast.SelectionSet, obj *bug.Snapshot) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bugImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bug")
		case "id":
			out.Values[i] = ec._Bug_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "humanId":
			out.Values[i] = ec._Bug_humanId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Bug_status(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "title":
			out.Values[i] = ec._Bug_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Bug_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._Bug_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdAt":
			out.Values[i] = ec._Bug_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastEdit":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Bug_lastEdit(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "comments":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Bug_comments(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "timeline":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Bug_timeline(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "operations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Bug_operations(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Bug_id(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Id(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_humanId(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.HumanId(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_status(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Bug().Status(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Bug_title(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_labels(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Label)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Bug_author(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_createdAt(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_lastEdit(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Bug().LastEdit(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_comments(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Bug_comments_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Bug().Comments(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.CommentConnection)
	rctx.Result = res

	return ec._CommentConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_timeline(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Bug_timeline_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Bug().Timeline(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.TimelineItemConnection)
	rctx.Result = res

	return ec._TimelineItemConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Bug_operations(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Bug_operations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Bug().Operations(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.OperationConnection)
	rctx.Result = res

	return ec._OperationConnection(ctx, field.Selections, &res)
}

var bugConnectionImplementors = []string{"BugConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BugConnection(ctx context.Context, sel ast.SelectionSet, obj *models.BugConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bugConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BugConnection")
		case "edges":
			out.Values[i] = ec._BugConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodes":
			out.Values[i] = ec._BugConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pageInfo":
			out.Values[i] = ec._BugConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "totalCount":
			out.Values[i] = ec._BugConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _BugConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "BugConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Edges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.BugEdge)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._BugEdge(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _BugConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "BugConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Nodes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Snapshot)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Bug(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _BugConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "BugConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.PageInfo, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PageInfo)
	rctx.Result = res

	return ec._PageInfo(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _BugConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "BugConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

var bugEdgeImplementors = []string{"BugEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BugEdge(ctx context.Context, sel ast.SelectionSet, obj *models.BugEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bugEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BugEdge")
		case "cursor":
			out.Values[i] = ec._BugEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._BugEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _BugEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.BugEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "BugEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _BugEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.BugEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "BugEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

var commentImplementors = []string{"Comment", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Comment(ctx context.Context, sel ast.SelectionSet, obj *bug.Comment) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, commentImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Comment")
		case "author":
			out.Values[i] = ec._Comment_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._Comment_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			out.Values[i] = ec._Comment_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Comment_author(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Comment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Comment_message(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Comment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Comment_files(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Comment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Files, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]git.Hash)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

var commentConnectionImplementors = []string{"CommentConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentConnection(ctx context.Context, sel ast.SelectionSet, obj *models.CommentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, commentConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentConnection")
		case "edges":
			out.Values[i] = ec._CommentConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodes":
			out.Values[i] = ec._CommentConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pageInfo":
			out.Values[i] = ec._CommentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "totalCount":
			out.Values[i] = ec._CommentConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CommentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Edges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.CommentEdge)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._CommentEdge(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _CommentConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Nodes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Comment)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Comment(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _CommentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.PageInfo, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PageInfo)
	rctx.Result = res

	return ec._PageInfo(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _CommentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

var commentEdgeImplementors = []string{"CommentEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentEdge(ctx context.Context, sel ast.SelectionSet, obj *models.CommentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, commentEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentEdge")
		case "cursor":
			out.Values[i] = ec._CommentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._CommentEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CommentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.CommentEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CommentEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.CommentEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Comment)
	rctx.Result = res

	return ec._Comment(ctx, field.Selections, &res)
}

var commentHistoryStepImplementors = []string{"CommentHistoryStep"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentHistoryStep(ctx context.Context, sel ast.SelectionSet, obj *bug.CommentHistoryStep) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, commentHistoryStepImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentHistoryStep")
		case "message":
			out.Values[i] = ec._CommentHistoryStep_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._CommentHistoryStep_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CommentHistoryStep_message(ctx context.Context, field graphql.CollectedField, obj *bug.CommentHistoryStep) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentHistoryStep",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CommentHistoryStep_date(ctx context.Context, field graphql.CollectedField, obj *bug.CommentHistoryStep) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CommentHistoryStep",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.CommentHistoryStep().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

var createOperationImplementors = []string{"CreateOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CreateOperation(ctx context.Context, sel ast.SelectionSet, obj *bug.CreateOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, createOperationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateOperation")
		case "hash":
			out.Values[i] = ec._CreateOperation_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._CreateOperation_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._CreateOperation_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "title":
			out.Values[i] = ec._CreateOperation_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._CreateOperation_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			out.Values[i] = ec._CreateOperation_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CreateOperation_hash(ctx context.Context, field graphql.CollectedField, obj *bug.CreateOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash()
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _CreateOperation_author(ctx context.Context, field graphql.CollectedField, obj *bug.CreateOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateOperation_date(ctx context.Context, field graphql.CollectedField, obj *bug.CreateOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.CreateOperation().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateOperation_title(ctx context.Context, field graphql.CollectedField, obj *bug.CreateOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateOperation_message(ctx context.Context, field graphql.CollectedField, obj *bug.CreateOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateOperation_files(ctx context.Context, field graphql.CollectedField, obj *bug.CreateOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Files, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]git.Hash)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

var createTimelineItemImplementors = []string{"CreateTimelineItem", "TimelineItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CreateTimelineItem(ctx context.Context, sel ast.SelectionSet, obj *bug.CreateTimelineItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, createTimelineItemImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTimelineItem")
		case "hash":
			out.Values[i] = ec._CreateTimelineItem_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._CreateTimelineItem_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._CreateTimelineItem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			out.Values[i] = ec._CreateTimelineItem_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._CreateTimelineItem_createdAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "lastEdit":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._CreateTimelineItem_lastEdit(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "edited":
			out.Values[i] = ec._CreateTimelineItem_edited(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "history":
			out.Values[i] = ec._CreateTimelineItem_history(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_hash(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_author(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_message(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_files(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Files, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]git.Hash)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_createdAt(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.CreateTimelineItem().CreatedAt(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_lastEdit(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.CreateTimelineItem().LastEdit(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_edited(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Edited(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateTimelineItem_history(ctx context.Context, field graphql.CollectedField, obj *bug.CreateTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "CreateTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.History, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.CommentHistoryStep)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._CommentHistoryStep(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var editCommentOperationImplementors = []string{"EditCommentOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EditCommentOperation(ctx context.Context, sel ast.SelectionSet, obj *bug.EditCommentOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, editCommentOperationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EditCommentOperation")
		case "hash":
			out.Values[i] = ec._EditCommentOperation_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._EditCommentOperation_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._EditCommentOperation_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "target":
			out.Values[i] = ec._EditCommentOperation_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._EditCommentOperation_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			out.Values[i] = ec._EditCommentOperation_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EditCommentOperation_hash(ctx context.Context, field graphql.CollectedField, obj *bug.EditCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "EditCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash()
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _EditCommentOperation_author(ctx context.Context, field graphql.CollectedField, obj *bug.EditCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "EditCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _EditCommentOperation_date(ctx context.Context, field graphql.CollectedField, obj *bug.EditCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "EditCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.EditCommentOperation().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _EditCommentOperation_target(ctx context.Context, field graphql.CollectedField, obj *bug.EditCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "EditCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Target, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _EditCommentOperation_message(ctx context.Context, field graphql.CollectedField, obj *bug.EditCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "EditCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EditCommentOperation_files(ctx context.Context, field graphql.CollectedField, obj *bug.EditCommentOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "EditCommentOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Files, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]git.Hash)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

var labelChangeOperationImplementors = []string{"LabelChangeOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LabelChangeOperation(ctx context.Context, sel ast.SelectionSet, obj *bug.LabelChangeOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, labelChangeOperationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelChangeOperation")
		case "hash":
			out.Values[i] = ec._LabelChangeOperation_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._LabelChangeOperation_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._LabelChangeOperation_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "added":
			out.Values[i] = ec._LabelChangeOperation_added(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "removed":
			out.Values[i] = ec._LabelChangeOperation_removed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeOperation_hash(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash()
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeOperation_author(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeOperation_date(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.LabelChangeOperation().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeOperation_added(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Added, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Label)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeOperation_removed(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Removed, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Label)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

var labelChangeTimelineItemImplementors = []string{"LabelChangeTimelineItem", "TimelineItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LabelChangeTimelineItem(ctx context.Context, sel ast.SelectionSet, obj *bug.LabelChangeTimelineItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, labelChangeTimelineItemImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelChangeTimelineItem")
		case "hash":
			out.Values[i] = ec._LabelChangeTimelineItem_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._LabelChangeTimelineItem_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._LabelChangeTimelineItem_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "added":
			out.Values[i] = ec._LabelChangeTimelineItem_added(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "removed":
			out.Values[i] = ec._LabelChangeTimelineItem_removed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeTimelineItem_hash(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeTimelineItem_author(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeTimelineItem_date(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.LabelChangeTimelineItem().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeTimelineItem_added(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Added, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Label)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _LabelChangeTimelineItem_removed(ctx context.Context, field graphql.CollectedField, obj *bug.LabelChangeTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "LabelChangeTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Removed, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Label)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "newBug":
			out.Values[i] = ec._Mutation_newBug(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addComment":
			out.Values[i] = ec._Mutation_addComment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "changeLabels":
			out.Values[i] = ec._Mutation_changeLabels(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "open":
			out.Values[i] = ec._Mutation_open(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "close":
			out.Values[i] = ec._Mutation_close(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "setTitle":
			out.Values[i] = ec._Mutation_setTitle(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "commit":
			out.Values[i] = ec._Mutation_commit(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_newBug(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_newBug_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().NewBug(ctx, args["repoRef"].(*string), args["title"].(string), args["message"].(string), args["files"].([]git.Hash))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_addComment(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_addComment_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().AddComment(ctx, args["repoRef"].(*string), args["prefix"].(string), args["message"].(string), args["files"].([]git.Hash))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_changeLabels(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_changeLabels_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().ChangeLabels(ctx, args["repoRef"].(*string), args["prefix"].(string), args["added"].([]string), args["removed"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_open(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_open_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Open(ctx, args["repoRef"].(*string), args["prefix"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_close(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_close_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Close(ctx, args["repoRef"].(*string), args["prefix"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_setTitle(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_setTitle_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().SetTitle(ctx, args["repoRef"].(*string), args["prefix"].(string), args["title"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_commit(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_commit_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Commit(ctx, args["repoRef"].(*string), args["prefix"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	rctx.Result = res

	return ec._Bug(ctx, field.Selections, &res)
}

var operationConnectionImplementors = []string{"OperationConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OperationConnection(ctx context.Context, sel ast.SelectionSet, obj *models.OperationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, operationConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationConnection")
		case "edges":
			out.Values[i] = ec._OperationConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodes":
			out.Values[i] = ec._OperationConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pageInfo":
			out.Values[i] = ec._OperationConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "totalCount":
			out.Values[i] = ec._OperationConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _OperationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OperationConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Edges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.OperationEdge)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._OperationEdge(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _OperationConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OperationConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Nodes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.Operation)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Operation(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _OperationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OperationConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.PageInfo, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PageInfo)
	rctx.Result = res

	return ec._PageInfo(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _OperationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OperationConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

var operationEdgeImplementors = []string{"OperationEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OperationEdge(ctx context.Context, sel ast.SelectionSet, obj *models.OperationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, operationEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationEdge")
		case "cursor":
			out.Values[i] = ec._OperationEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._OperationEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _OperationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.OperationEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OperationEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _OperationEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.OperationEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OperationEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Operation)
	rctx.Result = res

	return ec._Operation(ctx, field.Selections, &res)
}

var pageInfoImplementors = []string{"PageInfo"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *models.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, pageInfoImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.HasNextPage, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.HasPreviousPage, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.StartCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.EndCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var personImplementors = []string{"Person"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Person(ctx context.Context, sel ast.SelectionSet, obj *bug.Person) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, personImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Person")
		case "email":
			out.Values[i] = ec._Person_email(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Person_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "avatarUrl":
			out.Values[i] = ec._Person_avatarUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Person_email(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Person",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Email, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Person_name(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Person",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Person_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Person",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.AvatarUrl, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "defaultRepository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_defaultRepository(ctx, field)
				wg.Done()
			}(i, field)
		case "repository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_repository(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_defaultRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Query().DefaultRepository(ctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Repository)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Repository(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_repository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_repository_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Query().Repository(ctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Repository)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Repository(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.introspectType(args["name"].(string)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.introspectSchema(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var repositoryImplementors = []string{"Repository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *models.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, repositoryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "allBugs":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_allBugs(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "bug":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_bug(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Repository_allBugs(ctx context.Context, field graphql.CollectedField, obj *models.Repository) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Repository_allBugs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Repository().AllBugs(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int), args["query"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.BugConnection)
	rctx.Result = res

	return ec._BugConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_bug(ctx context.Context, field graphql.CollectedField, obj *models.Repository) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Repository_bug_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Repository().Bug(ctx, obj, args["prefix"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bug.Snapshot)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Bug(ctx, field.Selections, res)
}

var setStatusOperationImplementors = []string{"SetStatusOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetStatusOperation(ctx context.Context, sel ast.SelectionSet, obj *bug.SetStatusOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, setStatusOperationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetStatusOperation")
		case "hash":
			out.Values[i] = ec._SetStatusOperation_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._SetStatusOperation_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SetStatusOperation_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SetStatusOperation_status(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusOperation_hash(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash()
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusOperation_author(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusOperation_date(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.SetStatusOperation().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusOperation_status(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.SetStatusOperation().Status(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res
	return res
}

var setStatusTimelineItemImplementors = []string{"SetStatusTimelineItem", "TimelineItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetStatusTimelineItem(ctx context.Context, sel ast.SelectionSet, obj *bug.SetStatusTimelineItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, setStatusTimelineItemImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetStatusTimelineItem")
		case "hash":
			out.Values[i] = ec._SetStatusTimelineItem_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._SetStatusTimelineItem_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SetStatusTimelineItem_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SetStatusTimelineItem_status(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusTimelineItem_hash(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusTimelineItem_author(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusTimelineItem_date(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.SetStatusTimelineItem().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _SetStatusTimelineItem_status(ctx context.Context, field graphql.CollectedField, obj *bug.SetStatusTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetStatusTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.SetStatusTimelineItem().Status(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res
	return res
}

var setTitleOperationImplementors = []string{"SetTitleOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetTitleOperation(ctx context.Context, sel ast.SelectionSet, obj *bug.SetTitleOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, setTitleOperationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetTitleOperation")
		case "hash":
			out.Values[i] = ec._SetTitleOperation_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._SetTitleOperation_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SetTitleOperation_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "title":
			out.Values[i] = ec._SetTitleOperation_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "was":
			out.Values[i] = ec._SetTitleOperation_was(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleOperation_hash(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash()
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleOperation_author(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleOperation_date(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.SetTitleOperation().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleOperation_title(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleOperation_was(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleOperation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Was, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var setTitleTimelineItemImplementors = []string{"SetTitleTimelineItem", "TimelineItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetTitleTimelineItem(ctx context.Context, sel ast.SelectionSet, obj *bug.SetTitleTimelineItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, setTitleTimelineItemImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetTitleTimelineItem")
		case "hash":
			out.Values[i] = ec._SetTitleTimelineItem_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "author":
			out.Values[i] = ec._SetTitleTimelineItem_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SetTitleTimelineItem_date(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "title":
			out.Values[i] = ec._SetTitleTimelineItem_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "was":
			out.Values[i] = ec._SetTitleTimelineItem_was(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleTimelineItem_hash(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Hash(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(git.Hash)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleTimelineItem_author(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Author, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.Person)
	rctx.Result = res

	return ec._Person(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleTimelineItem_date(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.SetTitleTimelineItem().Date(ctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	return graphql.MarshalTime(res)
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleTimelineItem_title(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SetTitleTimelineItem_was(ctx context.Context, field graphql.CollectedField, obj *bug.SetTitleTimelineItem) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SetTitleTimelineItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Was, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var timelineItemConnectionImplementors = []string{"TimelineItemConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TimelineItemConnection(ctx context.Context, sel ast.SelectionSet, obj *models.TimelineItemConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, timelineItemConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TimelineItemConnection")
		case "edges":
			out.Values[i] = ec._TimelineItemConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodes":
			out.Values[i] = ec._TimelineItemConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pageInfo":
			out.Values[i] = ec._TimelineItemConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "totalCount":
			out.Values[i] = ec._TimelineItemConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TimelineItemConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.TimelineItemConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TimelineItemConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Edges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.TimelineItemEdge)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._TimelineItemEdge(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _TimelineItemConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.TimelineItemConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TimelineItemConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Nodes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]bug.TimelineItem)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._TimelineItem(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _TimelineItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.TimelineItemConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TimelineItemConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.PageInfo, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PageInfo)
	rctx.Result = res

	return ec._PageInfo(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _TimelineItemConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.TimelineItemConnection) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TimelineItemConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

var timelineItemEdgeImplementors = []string{"TimelineItemEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TimelineItemEdge(ctx context.Context, sel ast.SelectionSet, obj *models.TimelineItemEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, timelineItemEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TimelineItemEdge")
		case "cursor":
			out.Values[i] = ec._TimelineItemEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._TimelineItemEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TimelineItemEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.TimelineItemEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TimelineItemEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TimelineItemEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.TimelineItemEdge) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TimelineItemEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bug.TimelineItem)
	rctx.Result = res

	return ec._TimelineItem(ctx, field.Selections, &res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(ctx context.Context) (interface{}, error) {
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Authored(ctx context.Context, sel ast.SelectionSet, obj *models.Authored) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case bug.Comment:
		return ec._Comment(ctx, sel, &obj)
	case *bug.Comment:
		return ec._Comment(ctx, sel, obj)
	case bug.CreateOperation:
		return ec._CreateOperation(ctx, sel, &obj)
	case *bug.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case bug.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, &obj)
	case *bug.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case bug.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, &obj)
	case *bug.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case bug.EditCommentOperation:
		return ec._EditCommentOperation(ctx, sel, &obj)
	case *bug.EditCommentOperation:
		return ec._EditCommentOperation(ctx, sel, obj)
	case bug.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, &obj)
	case *bug.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case bug.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, &obj)
	case *bug.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Operation(ctx context.Context, sel ast.SelectionSet, obj *bug.Operation) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case *bug.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case *bug.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case *bug.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case *bug.EditCommentOperation:
		return ec._EditCommentOperation(ctx, sel, obj)
	case *bug.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case *bug.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TimelineItem(ctx context.Context, sel ast.SelectionSet, obj *bug.TimelineItem) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case *bug.CreateTimelineItem:
		return ec._CreateTimelineItem(ctx, sel, obj)
	case *bug.AddCommentTimelineItem:
		return ec._AddCommentTimelineItem(ctx, sel, obj)
	case bug.LabelChangeTimelineItem:
		return ec._LabelChangeTimelineItem(ctx, sel, &obj)
	case *bug.LabelChangeTimelineItem:
		return ec._LabelChangeTimelineItem(ctx, sel, obj)
	case bug.SetStatusTimelineItem:
		return ec._SetStatusTimelineItem(ctx, sel, &obj)
	case *bug.SetStatusTimelineItem:
		return ec._SetStatusTimelineItem(ctx, sel, obj)
	case bug.SetTitleTimelineItem:
		return ec._SetTitleTimelineItem(ctx, sel, &obj)
	case *bug.SetTitleTimelineItem:
		return ec._SetTitleTimelineItem(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name])
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `scalar Time
scalar Label
scalar Hash

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String!
  """When paginating forwards, the cursor to continue."""
  endCursor: String!
}

"""Represents an person in a git object."""
type Person {
  """The email of the person."""
  email: String

  """The name of the person."""
  name: String!

  """An url to an avatar"""
  avatarUrl: String
}

type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

"""Represents a comment on a bug."""
type Comment implements Authored {
  """The author of this comment."""
  author: Person!

  """The message of this comment."""
  message: String!

  """All media's hash referenced in this comment"""
  files: [Hash!]!
}

enum Status {
  OPEN
  CLOSED
}

"""An object that has an author."""
interface Authored {
  """The author of this object."""
  author: Person!
}

type OperationConnection {
  edges: [OperationEdge!]!
  nodes: [Operation!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OperationEdge {
  cursor: String!
  node: Operation!
}

"""An item in the timeline of events"""
interface TimelineItem {
  """The hash of the source operation"""
  hash: Hash!
}

"""An operation applied to a bug."""
interface Operation {
  """The hash of the operation"""
  hash: Hash!
  """The operations author."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!
}

type CreateOperation implements Operation & Authored {
  """The hash of the operation"""
  hash: Hash!
  """The author of this object."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!

  title: String!
  message: String!
  files: [Hash!]!
}

type SetTitleOperation implements Operation & Authored {
  """The hash of the operation"""
  hash: Hash!
  """The author of this object."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!

  title: String!
  was: String!
}

type AddCommentOperation implements Operation & Authored {
  """The hash of the operation"""
  hash: Hash!
  """The author of this object."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!

  message: String!
  files: [Hash!]!
}

type EditCommentOperation implements Operation & Authored {
  """The hash of the operation"""
  hash: Hash!
  """The author of this object."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!

  target: Hash!
  message: String!
  files: [Hash!]!
}

type SetStatusOperation implements Operation & Authored {
  """The hash of the operation"""
  hash: Hash!
  """The author of this object."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!

  status: Status!
}

type LabelChangeOperation implements Operation & Authored {
  """The hash of the operation"""
  hash: Hash!
  """The author of this object."""
  author: Person!
  """The datetime when this operation was issued."""
  date: Time!

  added: [Label!]!
  removed: [Label!]!
}

type TimelineItemConnection {
  edges: [TimelineItemEdge!]!
  nodes: [TimelineItem!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TimelineItemEdge {
  cursor: String!
  node: TimelineItem!
}

type CommentHistoryStep {
  message: String!
  date: Time!
}

type CreateTimelineItem implements TimelineItem {
  """The hash of the source operation"""
  hash: Hash!
  author: Person!
  message: String!
  files: [Hash!]!
  createdAt: Time!
  lastEdit: Time!
  edited: Boolean!
  history: [CommentHistoryStep!]!
}

type AddCommentTimelineItem implements TimelineItem {
  """The hash of the source operation"""
  hash: Hash!
  author: Person!
  message: String!
  files: [Hash!]!
  createdAt: Time!
  lastEdit: Time!
  edited: Boolean!
  history: [CommentHistoryStep!]!
}

type LabelChangeTimelineItem implements TimelineItem {
  """The hash of the source operation"""
  hash: Hash!
  author: Person!
  date: Time!
  added: [Label!]!
  removed: [Label!]!
}

type SetStatusTimelineItem implements TimelineItem {
  """The hash of the source operation"""
  hash: Hash!
  author: Person!
  date: Time!
  status: Status!
}

type SetTitleTimelineItem implements TimelineItem {
  """The hash of the source operation"""
  hash: Hash!
  author: Person!
  date: Time!
  title: String!
  was: String!
}

"""The connection type for Bug."""
type BugConnection {
  """A list of edges."""
  edges: [BugEdge!]!
  nodes: [Bug!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type BugEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Bug!
}

type Bug {
  id: String!
  humanId: String!
  status: Status!
  title: String!
  labels: [Label!]!
  author: Person!
  createdAt: Time!
  lastEdit: Time!

  comments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): CommentConnection!

  timeline(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): TimelineItemConnection!

  operations(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): OperationConnection!
}

type Repository {
  allBugs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
    """A query to select and order bugs"""
    query: String
  ): BugConnection!
  bug(prefix: String!): Bug
}

type Query {
  defaultRepository: Repository
  repository(id: String!): Repository
}

type Mutation {
  newBug(repoRef: String, title: String!, message: String!, files: [Hash!]): Bug!

  addComment(repoRef: String, prefix: String!, message: String!, files: [Hash!]): Bug!
  changeLabels(repoRef: String, prefix: String!, added: [String!], removed: [String!]): Bug!
  open(repoRef: String, prefix: String!): Bug!
  close(repoRef: String, prefix: String!): Bug!
  setTitle(repoRef: String, prefix: String!, title: String!): Bug!

  commit(repoRef: String, prefix: String!): Bug!
}
`},
)
