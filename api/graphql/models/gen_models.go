// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"fmt"
	"io"
	"strconv"

	"github.com/git-bug/git-bug/entities/bug"
	"github.com/git-bug/git-bug/entities/common"
	"github.com/git-bug/git-bug/entity/dag"
	"github.com/git-bug/git-bug/repository"
)

// An object that has an author.
type Authored interface {
	IsAuthored()
}

type BugAddCommentAndCloseInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
	// The message to be added to the bug.
	Message string `json:"message"`
	// The collection of file's hash required for the first message.
	Files []repository.Hash `json:"files,omitempty"`
}

type BugAddCommentAndClosePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting AddComment operation.
	CommentOperation *bug.AddCommentOperation `json:"commentOperation"`
	// The resulting SetStatusOperation.
	StatusOperation *bug.SetStatusOperation `json:"statusOperation"`
}

type BugAddCommentAndReopenInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
	// The message to be added to the bug.
	Message string `json:"message"`
	// The collection of file's hash required for the first message.
	Files []repository.Hash `json:"files,omitempty"`
}

type BugAddCommentAndReopenPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting AddComment operation.
	CommentOperation *bug.AddCommentOperation `json:"commentOperation"`
	// The resulting SetStatusOperation.
	StatusOperation *bug.SetStatusOperation `json:"statusOperation"`
}

type BugAddCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
	// The message to be added to the bug.
	Message string `json:"message"`
	// The collection of file's hash required for the first message.
	Files []repository.Hash `json:"files,omitempty"`
}

type BugAddCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation.
	Operation *bug.AddCommentOperation `json:"operation"`
}

type BugChange struct {
	Type ChangeType `json:"type"`
	Bug  BugWrapper `json:"bug"`
}

type BugChangeLabelInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
	// The list of label to add.
	Added []string `json:"added,omitempty"`
	// The list of label to remove.
	Removed []string `json:"Removed,omitempty"`
}

type BugChangeLabelPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation.
	Operation *bug.LabelChangeOperation `json:"operation"`
	// The effect each source label had.
	Results []*bug.LabelChangeResult `json:"results"`
}

type BugCommentConnection struct {
	Edges      []*BugCommentEdge `json:"edges"`
	Nodes      []*bug.Comment    `json:"nodes"`
	PageInfo   *PageInfo         `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

type BugCommentEdge struct {
	Cursor string       `json:"cursor"`
	Node   *bug.Comment `json:"node"`
}

// The connection type for Bug.
type BugConnection struct {
	// A list of edges.
	Edges []*BugEdge   `json:"edges"`
	Nodes []BugWrapper `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int `json:"totalCount"`
}

type BugCreateInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The title of the new bug.
	Title string `json:"title"`
	// The first message of the new bug.
	Message string `json:"message"`
	// The collection of file's hash required for the first message.
	Files []repository.Hash `json:"files,omitempty"`
}

type BugCreatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The created bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation.
	Operation *bug.CreateOperation `json:"operation"`
}

// An edge in a connection.
type BugEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node BugWrapper `json:"node"`
}

type BugEditCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// A prefix of the CombinedId of the comment to be changed.
	TargetPrefix string `json:"targetPrefix"`
	// The new message to be set.
	Message string `json:"message"`
	// The collection of file's hash required for the first message.
	Files []repository.Hash `json:"files,omitempty"`
}

type BugEditCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation.
	Operation *bug.EditCommentOperation `json:"operation"`
}

type BugSetTitleInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
	// The new title.
	Title string `json:"title"`
}

type BugSetTitlePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation
	Operation *bug.SetTitleOperation `json:"operation"`
}

type BugStatusCloseInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
}

type BugStatusClosePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation.
	Operation *bug.SetStatusOperation `json:"operation"`
}

type BugStatusOpenInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The name of the repository. If not set, the default repository is used.
	RepoRef *string `json:"repoRef,omitempty"`
	// The bug ID's prefix.
	Prefix string `json:"prefix"`
}

type BugStatusOpenPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The affected bug.
	Bug BugWrapper `json:"bug"`
	// The resulting operation.
	Operation *bug.SetStatusOperation `json:"operation"`
}

// The connection type for TimelineItem
type BugTimelineItemConnection struct {
	Edges      []*BugTimelineItemEdge `json:"edges"`
	Nodes      []bug.TimelineItem     `json:"nodes"`
	PageInfo   *PageInfo              `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// Represent a TimelineItem
type BugTimelineItemEdge struct {
	Cursor string           `json:"cursor"`
	Node   bug.TimelineItem `json:"node"`
}

type IdentityConnection struct {
	Edges      []*IdentityEdge   `json:"edges"`
	Nodes      []IdentityWrapper `json:"nodes"`
	PageInfo   *PageInfo         `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

type IdentityEdge struct {
	Cursor string          `json:"cursor"`
	Node   IdentityWrapper `json:"node"`
}

type LabelConnection struct {
	Edges      []*LabelEdge   `json:"edges"`
	Nodes      []common.Label `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type LabelEdge struct {
	Cursor string       `json:"cursor"`
	Node   common.Label `json:"node"`
}

type Mutation struct {
}

// The connection type for an Operation
type OperationConnection struct {
	Edges      []*OperationEdge `json:"edges"`
	Nodes      []dag.Operation  `json:"nodes"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// Represent an Operation
type OperationEdge struct {
	Cursor string        `json:"cursor"`
	Node   dag.Operation `json:"node"`
}

// Information about pagination in a connection.
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor string `json:"startCursor"`
	// When paginating forwards, the cursor to continue.
	EndCursor string `json:"endCursor"`
}

type Query struct {
}

type Subscription struct {
}

type ChangeType string

const (
	ChangeTypeCreated ChangeType = "CREATED"
	ChangeTypeUpdated ChangeType = "UPDATED"
)

var AllChangeType = []ChangeType{
	ChangeTypeCreated,
	ChangeTypeUpdated,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeCreated, ChangeTypeUpdated:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChangeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChangeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
