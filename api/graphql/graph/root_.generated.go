// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/git-bug/git-bug/api/graphql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AddCommentOperation() AddCommentOperationResolver
	AddCommentTimelineItem() AddCommentTimelineItemResolver
	Bug() BugResolver
	Color() ColorResolver
	Comment() CommentResolver
	CommentHistoryStep() CommentHistoryStepResolver
	CreateOperation() CreateOperationResolver
	CreateTimelineItem() CreateTimelineItemResolver
	EditCommentOperation() EditCommentOperationResolver
	Identity() IdentityResolver
	Label() LabelResolver
	LabelChangeOperation() LabelChangeOperationResolver
	LabelChangeTimelineItem() LabelChangeTimelineItemResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	SetStatusOperation() SetStatusOperationResolver
	SetStatusTimelineItem() SetStatusTimelineItemResolver
	SetTitleOperation() SetTitleOperationResolver
	SetTitleTimelineItem() SetTitleTimelineItemResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AddCommentAndCloseBugPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		CommentOperation func(childComplexity int) int
		StatusOperation  func(childComplexity int) int
	}

	AddCommentAndReopenBugPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		CommentOperation func(childComplexity int) int
		StatusOperation  func(childComplexity int) int
	}

	AddCommentOperation struct {
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Files   func(childComplexity int) int
		Id      func(childComplexity int) int
		Message func(childComplexity int) int
	}

	AddCommentPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	AddCommentTimelineItem struct {
		Author         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Edited         func(childComplexity int) int
		Files          func(childComplexity int) int
		History        func(childComplexity int) int
		ID             func(childComplexity int) int
		LastEdit       func(childComplexity int) int
		Message        func(childComplexity int) int
		MessageIsEmpty func(childComplexity int) int
	}

	Bug struct {
		Actors       func(childComplexity int, after *string, before *string, first *int, last *int) int
		Author       func(childComplexity int) int
		Comments     func(childComplexity int, after *string, before *string, first *int, last *int) int
		CreatedAt    func(childComplexity int) int
		HumanID      func(childComplexity int) int
		Id           func(childComplexity int) int
		Labels       func(childComplexity int) int
		LastEdit     func(childComplexity int) int
		Operations   func(childComplexity int, after *string, before *string, first *int, last *int) int
		Participants func(childComplexity int, after *string, before *string, first *int, last *int) int
		Status       func(childComplexity int) int
		Timeline     func(childComplexity int, after *string, before *string, first *int, last *int) int
		Title        func(childComplexity int) int
	}

	BugConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BugEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ChangeLabelPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
		Results          func(childComplexity int) int
	}

	CloseBugPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	Color struct {
		B func(childComplexity int) int
		G func(childComplexity int) int
		R func(childComplexity int) int
	}

	Comment struct {
		Author  func(childComplexity int) int
		Files   func(childComplexity int) int
		ID      func(childComplexity int) int
		Message func(childComplexity int) int
	}

	CommentConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CommentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CommentHistoryStep struct {
		Date    func(childComplexity int) int
		Message func(childComplexity int) int
	}

	CreateOperation struct {
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Files   func(childComplexity int) int
		Id      func(childComplexity int) int
		Message func(childComplexity int) int
		Title   func(childComplexity int) int
	}

	CreateTimelineItem struct {
		Author         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Edited         func(childComplexity int) int
		Files          func(childComplexity int) int
		History        func(childComplexity int) int
		ID             func(childComplexity int) int
		LastEdit       func(childComplexity int) int
		Message        func(childComplexity int) int
		MessageIsEmpty func(childComplexity int) int
	}

	EditCommentOperation struct {
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Files   func(childComplexity int) int
		Id      func(childComplexity int) int
		Message func(childComplexity int) int
		Target  func(childComplexity int) int
	}

	EditCommentPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	Identity struct {
		AvatarUrl   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		HumanID     func(childComplexity int) int
		Id          func(childComplexity int) int
		IsProtected func(childComplexity int) int
		Login       func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	IdentityConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IdentityEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Label struct {
		Color func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	LabelChangeOperation struct {
		Added   func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		Id      func(childComplexity int) int
		Removed func(childComplexity int) int
	}

	LabelChangeResult struct {
		Label  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	LabelChangeTimelineItem struct {
		Added   func(childComplexity int) int
		Author  func(childComplexity int) int
		Date    func(childComplexity int) int
		ID      func(childComplexity int) int
		Removed func(childComplexity int) int
	}

	LabelConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LabelEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		AddComment          func(childComplexity int, input models.AddCommentInput) int
		AddCommentAndClose  func(childComplexity int, input models.AddCommentAndCloseBugInput) int
		AddCommentAndReopen func(childComplexity int, input models.AddCommentAndReopenBugInput) int
		ChangeLabels        func(childComplexity int, input *models.ChangeLabelInput) int
		CloseBug            func(childComplexity int, input models.CloseBugInput) int
		EditComment         func(childComplexity int, input models.EditCommentInput) int
		NewBug              func(childComplexity int, input models.NewBugInput) int
		OpenBug             func(childComplexity int, input models.OpenBugInput) int
		SetTitle            func(childComplexity int, input models.SetTitleInput) int
	}

	NewBugPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	OpenBugPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	OperationConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OperationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Repository func(childComplexity int, ref *string) int
	}

	Repository struct {
		AllBugs       func(childComplexity int, after *string, before *string, first *int, last *int, query *string) int
		AllIdentities func(childComplexity int, after *string, before *string, first *int, last *int) int
		Bug           func(childComplexity int, prefix string) int
		Identity      func(childComplexity int, prefix string) int
		Name          func(childComplexity int) int
		UserIdentity  func(childComplexity int) int
		ValidLabels   func(childComplexity int, after *string, before *string, first *int, last *int) int
	}

	SetStatusOperation struct {
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		Id     func(childComplexity int) int
		Status func(childComplexity int) int
	}

	SetStatusTimelineItem struct {
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		ID     func(childComplexity int) int
		Status func(childComplexity int) int
	}

	SetTitleOperation struct {
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		Id     func(childComplexity int) int
		Title  func(childComplexity int) int
		Was    func(childComplexity int) int
	}

	SetTitlePayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	SetTitleTimelineItem struct {
		Author func(childComplexity int) int
		Date   func(childComplexity int) int
		ID     func(childComplexity int) int
		Title  func(childComplexity int) int
		Was    func(childComplexity int) int
	}

	TimelineItemConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TimelineItemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddCommentAndCloseBugPayload.bug":
		if e.complexity.AddCommentAndCloseBugPayload.Bug == nil {
			break
		}

		return e.complexity.AddCommentAndCloseBugPayload.Bug(childComplexity), true

	case "AddCommentAndCloseBugPayload.clientMutationId":
		if e.complexity.AddCommentAndCloseBugPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.AddCommentAndCloseBugPayload.ClientMutationID(childComplexity), true

	case "AddCommentAndCloseBugPayload.commentOperation":
		if e.complexity.AddCommentAndCloseBugPayload.CommentOperation == nil {
			break
		}

		return e.complexity.AddCommentAndCloseBugPayload.CommentOperation(childComplexity), true

	case "AddCommentAndCloseBugPayload.statusOperation":
		if e.complexity.AddCommentAndCloseBugPayload.StatusOperation == nil {
			break
		}

		return e.complexity.AddCommentAndCloseBugPayload.StatusOperation(childComplexity), true

	case "AddCommentAndReopenBugPayload.bug":
		if e.complexity.AddCommentAndReopenBugPayload.Bug == nil {
			break
		}

		return e.complexity.AddCommentAndReopenBugPayload.Bug(childComplexity), true

	case "AddCommentAndReopenBugPayload.clientMutationId":
		if e.complexity.AddCommentAndReopenBugPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.AddCommentAndReopenBugPayload.ClientMutationID(childComplexity), true

	case "AddCommentAndReopenBugPayload.commentOperation":
		if e.complexity.AddCommentAndReopenBugPayload.CommentOperation == nil {
			break
		}

		return e.complexity.AddCommentAndReopenBugPayload.CommentOperation(childComplexity), true

	case "AddCommentAndReopenBugPayload.statusOperation":
		if e.complexity.AddCommentAndReopenBugPayload.StatusOperation == nil {
			break
		}

		return e.complexity.AddCommentAndReopenBugPayload.StatusOperation(childComplexity), true

	case "AddCommentOperation.author":
		if e.complexity.AddCommentOperation.Author == nil {
			break
		}

		return e.complexity.AddCommentOperation.Author(childComplexity), true

	case "AddCommentOperation.date":
		if e.complexity.AddCommentOperation.Date == nil {
			break
		}

		return e.complexity.AddCommentOperation.Date(childComplexity), true

	case "AddCommentOperation.files":
		if e.complexity.AddCommentOperation.Files == nil {
			break
		}

		return e.complexity.AddCommentOperation.Files(childComplexity), true

	case "AddCommentOperation.id":
		if e.complexity.AddCommentOperation.Id == nil {
			break
		}

		return e.complexity.AddCommentOperation.Id(childComplexity), true

	case "AddCommentOperation.message":
		if e.complexity.AddCommentOperation.Message == nil {
			break
		}

		return e.complexity.AddCommentOperation.Message(childComplexity), true

	case "AddCommentPayload.bug":
		if e.complexity.AddCommentPayload.Bug == nil {
			break
		}

		return e.complexity.AddCommentPayload.Bug(childComplexity), true

	case "AddCommentPayload.clientMutationId":
		if e.complexity.AddCommentPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.AddCommentPayload.ClientMutationID(childComplexity), true

	case "AddCommentPayload.operation":
		if e.complexity.AddCommentPayload.Operation == nil {
			break
		}

		return e.complexity.AddCommentPayload.Operation(childComplexity), true

	case "AddCommentTimelineItem.author":
		if e.complexity.AddCommentTimelineItem.Author == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Author(childComplexity), true

	case "AddCommentTimelineItem.createdAt":
		if e.complexity.AddCommentTimelineItem.CreatedAt == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.CreatedAt(childComplexity), true

	case "AddCommentTimelineItem.edited":
		if e.complexity.AddCommentTimelineItem.Edited == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Edited(childComplexity), true

	case "AddCommentTimelineItem.files":
		if e.complexity.AddCommentTimelineItem.Files == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Files(childComplexity), true

	case "AddCommentTimelineItem.history":
		if e.complexity.AddCommentTimelineItem.History == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.History(childComplexity), true

	case "AddCommentTimelineItem.id":
		if e.complexity.AddCommentTimelineItem.ID == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.ID(childComplexity), true

	case "AddCommentTimelineItem.lastEdit":
		if e.complexity.AddCommentTimelineItem.LastEdit == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.LastEdit(childComplexity), true

	case "AddCommentTimelineItem.message":
		if e.complexity.AddCommentTimelineItem.Message == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.Message(childComplexity), true

	case "AddCommentTimelineItem.messageIsEmpty":
		if e.complexity.AddCommentTimelineItem.MessageIsEmpty == nil {
			break
		}

		return e.complexity.AddCommentTimelineItem.MessageIsEmpty(childComplexity), true

	case "Bug.actors":
		if e.complexity.Bug.Actors == nil {
			break
		}

		args, err := ec.field_Bug_actors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Actors(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.author":
		if e.complexity.Bug.Author == nil {
			break
		}

		return e.complexity.Bug.Author(childComplexity), true

	case "Bug.comments":
		if e.complexity.Bug.Comments == nil {
			break
		}

		args, err := ec.field_Bug_comments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Comments(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.createdAt":
		if e.complexity.Bug.CreatedAt == nil {
			break
		}

		return e.complexity.Bug.CreatedAt(childComplexity), true

	case "Bug.humanId":
		if e.complexity.Bug.HumanID == nil {
			break
		}

		return e.complexity.Bug.HumanID(childComplexity), true

	case "Bug.id":
		if e.complexity.Bug.Id == nil {
			break
		}

		return e.complexity.Bug.Id(childComplexity), true

	case "Bug.labels":
		if e.complexity.Bug.Labels == nil {
			break
		}

		return e.complexity.Bug.Labels(childComplexity), true

	case "Bug.lastEdit":
		if e.complexity.Bug.LastEdit == nil {
			break
		}

		return e.complexity.Bug.LastEdit(childComplexity), true

	case "Bug.operations":
		if e.complexity.Bug.Operations == nil {
			break
		}

		args, err := ec.field_Bug_operations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Operations(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.participants":
		if e.complexity.Bug.Participants == nil {
			break
		}

		args, err := ec.field_Bug_participants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Participants(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.status":
		if e.complexity.Bug.Status == nil {
			break
		}

		return e.complexity.Bug.Status(childComplexity), true

	case "Bug.timeline":
		if e.complexity.Bug.Timeline == nil {
			break
		}

		args, err := ec.field_Bug_timeline_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Timeline(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.title":
		if e.complexity.Bug.Title == nil {
			break
		}

		return e.complexity.Bug.Title(childComplexity), true

	case "BugConnection.edges":
		if e.complexity.BugConnection.Edges == nil {
			break
		}

		return e.complexity.BugConnection.Edges(childComplexity), true

	case "BugConnection.nodes":
		if e.complexity.BugConnection.Nodes == nil {
			break
		}

		return e.complexity.BugConnection.Nodes(childComplexity), true

	case "BugConnection.pageInfo":
		if e.complexity.BugConnection.PageInfo == nil {
			break
		}

		return e.complexity.BugConnection.PageInfo(childComplexity), true

	case "BugConnection.totalCount":
		if e.complexity.BugConnection.TotalCount == nil {
			break
		}

		return e.complexity.BugConnection.TotalCount(childComplexity), true

	case "BugEdge.cursor":
		if e.complexity.BugEdge.Cursor == nil {
			break
		}

		return e.complexity.BugEdge.Cursor(childComplexity), true

	case "BugEdge.node":
		if e.complexity.BugEdge.Node == nil {
			break
		}

		return e.complexity.BugEdge.Node(childComplexity), true

	case "ChangeLabelPayload.bug":
		if e.complexity.ChangeLabelPayload.Bug == nil {
			break
		}

		return e.complexity.ChangeLabelPayload.Bug(childComplexity), true

	case "ChangeLabelPayload.clientMutationId":
		if e.complexity.ChangeLabelPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.ChangeLabelPayload.ClientMutationID(childComplexity), true

	case "ChangeLabelPayload.operation":
		if e.complexity.ChangeLabelPayload.Operation == nil {
			break
		}

		return e.complexity.ChangeLabelPayload.Operation(childComplexity), true

	case "ChangeLabelPayload.results":
		if e.complexity.ChangeLabelPayload.Results == nil {
			break
		}

		return e.complexity.ChangeLabelPayload.Results(childComplexity), true

	case "CloseBugPayload.bug":
		if e.complexity.CloseBugPayload.Bug == nil {
			break
		}

		return e.complexity.CloseBugPayload.Bug(childComplexity), true

	case "CloseBugPayload.clientMutationId":
		if e.complexity.CloseBugPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.CloseBugPayload.ClientMutationID(childComplexity), true

	case "CloseBugPayload.operation":
		if e.complexity.CloseBugPayload.Operation == nil {
			break
		}

		return e.complexity.CloseBugPayload.Operation(childComplexity), true

	case "Color.B":
		if e.complexity.Color.B == nil {
			break
		}

		return e.complexity.Color.B(childComplexity), true

	case "Color.G":
		if e.complexity.Color.G == nil {
			break
		}

		return e.complexity.Color.G(childComplexity), true

	case "Color.R":
		if e.complexity.Color.R == nil {
			break
		}

		return e.complexity.Color.R(childComplexity), true

	case "Comment.author":
		if e.complexity.Comment.Author == nil {
			break
		}

		return e.complexity.Comment.Author(childComplexity), true

	case "Comment.files":
		if e.complexity.Comment.Files == nil {
			break
		}

		return e.complexity.Comment.Files(childComplexity), true

	case "Comment.id":
		if e.complexity.Comment.ID == nil {
			break
		}

		return e.complexity.Comment.ID(childComplexity), true

	case "Comment.message":
		if e.complexity.Comment.Message == nil {
			break
		}

		return e.complexity.Comment.Message(childComplexity), true

	case "CommentConnection.edges":
		if e.complexity.CommentConnection.Edges == nil {
			break
		}

		return e.complexity.CommentConnection.Edges(childComplexity), true

	case "CommentConnection.nodes":
		if e.complexity.CommentConnection.Nodes == nil {
			break
		}

		return e.complexity.CommentConnection.Nodes(childComplexity), true

	case "CommentConnection.pageInfo":
		if e.complexity.CommentConnection.PageInfo == nil {
			break
		}

		return e.complexity.CommentConnection.PageInfo(childComplexity), true

	case "CommentConnection.totalCount":
		if e.complexity.CommentConnection.TotalCount == nil {
			break
		}

		return e.complexity.CommentConnection.TotalCount(childComplexity), true

	case "CommentEdge.cursor":
		if e.complexity.CommentEdge.Cursor == nil {
			break
		}

		return e.complexity.CommentEdge.Cursor(childComplexity), true

	case "CommentEdge.node":
		if e.complexity.CommentEdge.Node == nil {
			break
		}

		return e.complexity.CommentEdge.Node(childComplexity), true

	case "CommentHistoryStep.date":
		if e.complexity.CommentHistoryStep.Date == nil {
			break
		}

		return e.complexity.CommentHistoryStep.Date(childComplexity), true

	case "CommentHistoryStep.message":
		if e.complexity.CommentHistoryStep.Message == nil {
			break
		}

		return e.complexity.CommentHistoryStep.Message(childComplexity), true

	case "CreateOperation.author":
		if e.complexity.CreateOperation.Author == nil {
			break
		}

		return e.complexity.CreateOperation.Author(childComplexity), true

	case "CreateOperation.date":
		if e.complexity.CreateOperation.Date == nil {
			break
		}

		return e.complexity.CreateOperation.Date(childComplexity), true

	case "CreateOperation.files":
		if e.complexity.CreateOperation.Files == nil {
			break
		}

		return e.complexity.CreateOperation.Files(childComplexity), true

	case "CreateOperation.id":
		if e.complexity.CreateOperation.Id == nil {
			break
		}

		return e.complexity.CreateOperation.Id(childComplexity), true

	case "CreateOperation.message":
		if e.complexity.CreateOperation.Message == nil {
			break
		}

		return e.complexity.CreateOperation.Message(childComplexity), true

	case "CreateOperation.title":
		if e.complexity.CreateOperation.Title == nil {
			break
		}

		return e.complexity.CreateOperation.Title(childComplexity), true

	case "CreateTimelineItem.author":
		if e.complexity.CreateTimelineItem.Author == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Author(childComplexity), true

	case "CreateTimelineItem.createdAt":
		if e.complexity.CreateTimelineItem.CreatedAt == nil {
			break
		}

		return e.complexity.CreateTimelineItem.CreatedAt(childComplexity), true

	case "CreateTimelineItem.edited":
		if e.complexity.CreateTimelineItem.Edited == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Edited(childComplexity), true

	case "CreateTimelineItem.files":
		if e.complexity.CreateTimelineItem.Files == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Files(childComplexity), true

	case "CreateTimelineItem.history":
		if e.complexity.CreateTimelineItem.History == nil {
			break
		}

		return e.complexity.CreateTimelineItem.History(childComplexity), true

	case "CreateTimelineItem.id":
		if e.complexity.CreateTimelineItem.ID == nil {
			break
		}

		return e.complexity.CreateTimelineItem.ID(childComplexity), true

	case "CreateTimelineItem.lastEdit":
		if e.complexity.CreateTimelineItem.LastEdit == nil {
			break
		}

		return e.complexity.CreateTimelineItem.LastEdit(childComplexity), true

	case "CreateTimelineItem.message":
		if e.complexity.CreateTimelineItem.Message == nil {
			break
		}

		return e.complexity.CreateTimelineItem.Message(childComplexity), true

	case "CreateTimelineItem.messageIsEmpty":
		if e.complexity.CreateTimelineItem.MessageIsEmpty == nil {
			break
		}

		return e.complexity.CreateTimelineItem.MessageIsEmpty(childComplexity), true

	case "EditCommentOperation.author":
		if e.complexity.EditCommentOperation.Author == nil {
			break
		}

		return e.complexity.EditCommentOperation.Author(childComplexity), true

	case "EditCommentOperation.date":
		if e.complexity.EditCommentOperation.Date == nil {
			break
		}

		return e.complexity.EditCommentOperation.Date(childComplexity), true

	case "EditCommentOperation.files":
		if e.complexity.EditCommentOperation.Files == nil {
			break
		}

		return e.complexity.EditCommentOperation.Files(childComplexity), true

	case "EditCommentOperation.id":
		if e.complexity.EditCommentOperation.Id == nil {
			break
		}

		return e.complexity.EditCommentOperation.Id(childComplexity), true

	case "EditCommentOperation.message":
		if e.complexity.EditCommentOperation.Message == nil {
			break
		}

		return e.complexity.EditCommentOperation.Message(childComplexity), true

	case "EditCommentOperation.target":
		if e.complexity.EditCommentOperation.Target == nil {
			break
		}

		return e.complexity.EditCommentOperation.Target(childComplexity), true

	case "EditCommentPayload.bug":
		if e.complexity.EditCommentPayload.Bug == nil {
			break
		}

		return e.complexity.EditCommentPayload.Bug(childComplexity), true

	case "EditCommentPayload.clientMutationId":
		if e.complexity.EditCommentPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.EditCommentPayload.ClientMutationID(childComplexity), true

	case "EditCommentPayload.operation":
		if e.complexity.EditCommentPayload.Operation == nil {
			break
		}

		return e.complexity.EditCommentPayload.Operation(childComplexity), true

	case "Identity.avatarUrl":
		if e.complexity.Identity.AvatarUrl == nil {
			break
		}

		return e.complexity.Identity.AvatarUrl(childComplexity), true

	case "Identity.displayName":
		if e.complexity.Identity.DisplayName == nil {
			break
		}

		return e.complexity.Identity.DisplayName(childComplexity), true

	case "Identity.email":
		if e.complexity.Identity.Email == nil {
			break
		}

		return e.complexity.Identity.Email(childComplexity), true

	case "Identity.humanId":
		if e.complexity.Identity.HumanID == nil {
			break
		}

		return e.complexity.Identity.HumanID(childComplexity), true

	case "Identity.id":
		if e.complexity.Identity.Id == nil {
			break
		}

		return e.complexity.Identity.Id(childComplexity), true

	case "Identity.isProtected":
		if e.complexity.Identity.IsProtected == nil {
			break
		}

		return e.complexity.Identity.IsProtected(childComplexity), true

	case "Identity.login":
		if e.complexity.Identity.Login == nil {
			break
		}

		return e.complexity.Identity.Login(childComplexity), true

	case "Identity.name":
		if e.complexity.Identity.Name == nil {
			break
		}

		return e.complexity.Identity.Name(childComplexity), true

	case "IdentityConnection.edges":
		if e.complexity.IdentityConnection.Edges == nil {
			break
		}

		return e.complexity.IdentityConnection.Edges(childComplexity), true

	case "IdentityConnection.nodes":
		if e.complexity.IdentityConnection.Nodes == nil {
			break
		}

		return e.complexity.IdentityConnection.Nodes(childComplexity), true

	case "IdentityConnection.pageInfo":
		if e.complexity.IdentityConnection.PageInfo == nil {
			break
		}

		return e.complexity.IdentityConnection.PageInfo(childComplexity), true

	case "IdentityConnection.totalCount":
		if e.complexity.IdentityConnection.TotalCount == nil {
			break
		}

		return e.complexity.IdentityConnection.TotalCount(childComplexity), true

	case "IdentityEdge.cursor":
		if e.complexity.IdentityEdge.Cursor == nil {
			break
		}

		return e.complexity.IdentityEdge.Cursor(childComplexity), true

	case "IdentityEdge.node":
		if e.complexity.IdentityEdge.Node == nil {
			break
		}

		return e.complexity.IdentityEdge.Node(childComplexity), true

	case "Label.color":
		if e.complexity.Label.Color == nil {
			break
		}

		return e.complexity.Label.Color(childComplexity), true

	case "Label.name":
		if e.complexity.Label.Name == nil {
			break
		}

		return e.complexity.Label.Name(childComplexity), true

	case "LabelChangeOperation.added":
		if e.complexity.LabelChangeOperation.Added == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Added(childComplexity), true

	case "LabelChangeOperation.author":
		if e.complexity.LabelChangeOperation.Author == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Author(childComplexity), true

	case "LabelChangeOperation.date":
		if e.complexity.LabelChangeOperation.Date == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Date(childComplexity), true

	case "LabelChangeOperation.id":
		if e.complexity.LabelChangeOperation.Id == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Id(childComplexity), true

	case "LabelChangeOperation.removed":
		if e.complexity.LabelChangeOperation.Removed == nil {
			break
		}

		return e.complexity.LabelChangeOperation.Removed(childComplexity), true

	case "LabelChangeResult.label":
		if e.complexity.LabelChangeResult.Label == nil {
			break
		}

		return e.complexity.LabelChangeResult.Label(childComplexity), true

	case "LabelChangeResult.status":
		if e.complexity.LabelChangeResult.Status == nil {
			break
		}

		return e.complexity.LabelChangeResult.Status(childComplexity), true

	case "LabelChangeTimelineItem.added":
		if e.complexity.LabelChangeTimelineItem.Added == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Added(childComplexity), true

	case "LabelChangeTimelineItem.author":
		if e.complexity.LabelChangeTimelineItem.Author == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Author(childComplexity), true

	case "LabelChangeTimelineItem.date":
		if e.complexity.LabelChangeTimelineItem.Date == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Date(childComplexity), true

	case "LabelChangeTimelineItem.id":
		if e.complexity.LabelChangeTimelineItem.ID == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.ID(childComplexity), true

	case "LabelChangeTimelineItem.removed":
		if e.complexity.LabelChangeTimelineItem.Removed == nil {
			break
		}

		return e.complexity.LabelChangeTimelineItem.Removed(childComplexity), true

	case "LabelConnection.edges":
		if e.complexity.LabelConnection.Edges == nil {
			break
		}

		return e.complexity.LabelConnection.Edges(childComplexity), true

	case "LabelConnection.nodes":
		if e.complexity.LabelConnection.Nodes == nil {
			break
		}

		return e.complexity.LabelConnection.Nodes(childComplexity), true

	case "LabelConnection.pageInfo":
		if e.complexity.LabelConnection.PageInfo == nil {
			break
		}

		return e.complexity.LabelConnection.PageInfo(childComplexity), true

	case "LabelConnection.totalCount":
		if e.complexity.LabelConnection.TotalCount == nil {
			break
		}

		return e.complexity.LabelConnection.TotalCount(childComplexity), true

	case "LabelEdge.cursor":
		if e.complexity.LabelEdge.Cursor == nil {
			break
		}

		return e.complexity.LabelEdge.Cursor(childComplexity), true

	case "LabelEdge.node":
		if e.complexity.LabelEdge.Node == nil {
			break
		}

		return e.complexity.LabelEdge.Node(childComplexity), true

	case "Mutation.addComment":
		if e.complexity.Mutation.AddComment == nil {
			break
		}

		args, err := ec.field_Mutation_addComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddComment(childComplexity, args["input"].(models.AddCommentInput)), true

	case "Mutation.addCommentAndClose":
		if e.complexity.Mutation.AddCommentAndClose == nil {
			break
		}

		args, err := ec.field_Mutation_addCommentAndClose_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddCommentAndClose(childComplexity, args["input"].(models.AddCommentAndCloseBugInput)), true

	case "Mutation.addCommentAndReopen":
		if e.complexity.Mutation.AddCommentAndReopen == nil {
			break
		}

		args, err := ec.field_Mutation_addCommentAndReopen_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddCommentAndReopen(childComplexity, args["input"].(models.AddCommentAndReopenBugInput)), true

	case "Mutation.changeLabels":
		if e.complexity.Mutation.ChangeLabels == nil {
			break
		}

		args, err := ec.field_Mutation_changeLabels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangeLabels(childComplexity, args["input"].(*models.ChangeLabelInput)), true

	case "Mutation.closeBug":
		if e.complexity.Mutation.CloseBug == nil {
			break
		}

		args, err := ec.field_Mutation_closeBug_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CloseBug(childComplexity, args["input"].(models.CloseBugInput)), true

	case "Mutation.editComment":
		if e.complexity.Mutation.EditComment == nil {
			break
		}

		args, err := ec.field_Mutation_editComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditComment(childComplexity, args["input"].(models.EditCommentInput)), true

	case "Mutation.newBug":
		if e.complexity.Mutation.NewBug == nil {
			break
		}

		args, err := ec.field_Mutation_newBug_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewBug(childComplexity, args["input"].(models.NewBugInput)), true

	case "Mutation.openBug":
		if e.complexity.Mutation.OpenBug == nil {
			break
		}

		args, err := ec.field_Mutation_openBug_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OpenBug(childComplexity, args["input"].(models.OpenBugInput)), true

	case "Mutation.setTitle":
		if e.complexity.Mutation.SetTitle == nil {
			break
		}

		args, err := ec.field_Mutation_setTitle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTitle(childComplexity, args["input"].(models.SetTitleInput)), true

	case "NewBugPayload.bug":
		if e.complexity.NewBugPayload.Bug == nil {
			break
		}

		return e.complexity.NewBugPayload.Bug(childComplexity), true

	case "NewBugPayload.clientMutationId":
		if e.complexity.NewBugPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.NewBugPayload.ClientMutationID(childComplexity), true

	case "NewBugPayload.operation":
		if e.complexity.NewBugPayload.Operation == nil {
			break
		}

		return e.complexity.NewBugPayload.Operation(childComplexity), true

	case "OpenBugPayload.bug":
		if e.complexity.OpenBugPayload.Bug == nil {
			break
		}

		return e.complexity.OpenBugPayload.Bug(childComplexity), true

	case "OpenBugPayload.clientMutationId":
		if e.complexity.OpenBugPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.OpenBugPayload.ClientMutationID(childComplexity), true

	case "OpenBugPayload.operation":
		if e.complexity.OpenBugPayload.Operation == nil {
			break
		}

		return e.complexity.OpenBugPayload.Operation(childComplexity), true

	case "OperationConnection.edges":
		if e.complexity.OperationConnection.Edges == nil {
			break
		}

		return e.complexity.OperationConnection.Edges(childComplexity), true

	case "OperationConnection.nodes":
		if e.complexity.OperationConnection.Nodes == nil {
			break
		}

		return e.complexity.OperationConnection.Nodes(childComplexity), true

	case "OperationConnection.pageInfo":
		if e.complexity.OperationConnection.PageInfo == nil {
			break
		}

		return e.complexity.OperationConnection.PageInfo(childComplexity), true

	case "OperationConnection.totalCount":
		if e.complexity.OperationConnection.TotalCount == nil {
			break
		}

		return e.complexity.OperationConnection.TotalCount(childComplexity), true

	case "OperationEdge.cursor":
		if e.complexity.OperationEdge.Cursor == nil {
			break
		}

		return e.complexity.OperationEdge.Cursor(childComplexity), true

	case "OperationEdge.node":
		if e.complexity.OperationEdge.Node == nil {
			break
		}

		return e.complexity.OperationEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.repository":
		if e.complexity.Query.Repository == nil {
			break
		}

		args, err := ec.field_Query_repository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repository(childComplexity, args["ref"].(*string)), true

	case "Repository.allBugs":
		if e.complexity.Repository.AllBugs == nil {
			break
		}

		args, err := ec.field_Repository_allBugs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.AllBugs(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int), args["query"].(*string)), true

	case "Repository.allIdentities":
		if e.complexity.Repository.AllIdentities == nil {
			break
		}

		args, err := ec.field_Repository_allIdentities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.AllIdentities(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Repository.bug":
		if e.complexity.Repository.Bug == nil {
			break
		}

		args, err := ec.field_Repository_bug_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Bug(childComplexity, args["prefix"].(string)), true

	case "Repository.identity":
		if e.complexity.Repository.Identity == nil {
			break
		}

		args, err := ec.field_Repository_identity_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Identity(childComplexity, args["prefix"].(string)), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.userIdentity":
		if e.complexity.Repository.UserIdentity == nil {
			break
		}

		return e.complexity.Repository.UserIdentity(childComplexity), true

	case "Repository.validLabels":
		if e.complexity.Repository.ValidLabels == nil {
			break
		}

		args, err := ec.field_Repository_validLabels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.ValidLabels(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SetStatusOperation.author":
		if e.complexity.SetStatusOperation.Author == nil {
			break
		}

		return e.complexity.SetStatusOperation.Author(childComplexity), true

	case "SetStatusOperation.date":
		if e.complexity.SetStatusOperation.Date == nil {
			break
		}

		return e.complexity.SetStatusOperation.Date(childComplexity), true

	case "SetStatusOperation.id":
		if e.complexity.SetStatusOperation.Id == nil {
			break
		}

		return e.complexity.SetStatusOperation.Id(childComplexity), true

	case "SetStatusOperation.status":
		if e.complexity.SetStatusOperation.Status == nil {
			break
		}

		return e.complexity.SetStatusOperation.Status(childComplexity), true

	case "SetStatusTimelineItem.author":
		if e.complexity.SetStatusTimelineItem.Author == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Author(childComplexity), true

	case "SetStatusTimelineItem.date":
		if e.complexity.SetStatusTimelineItem.Date == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Date(childComplexity), true

	case "SetStatusTimelineItem.id":
		if e.complexity.SetStatusTimelineItem.ID == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.ID(childComplexity), true

	case "SetStatusTimelineItem.status":
		if e.complexity.SetStatusTimelineItem.Status == nil {
			break
		}

		return e.complexity.SetStatusTimelineItem.Status(childComplexity), true

	case "SetTitleOperation.author":
		if e.complexity.SetTitleOperation.Author == nil {
			break
		}

		return e.complexity.SetTitleOperation.Author(childComplexity), true

	case "SetTitleOperation.date":
		if e.complexity.SetTitleOperation.Date == nil {
			break
		}

		return e.complexity.SetTitleOperation.Date(childComplexity), true

	case "SetTitleOperation.id":
		if e.complexity.SetTitleOperation.Id == nil {
			break
		}

		return e.complexity.SetTitleOperation.Id(childComplexity), true

	case "SetTitleOperation.title":
		if e.complexity.SetTitleOperation.Title == nil {
			break
		}

		return e.complexity.SetTitleOperation.Title(childComplexity), true

	case "SetTitleOperation.was":
		if e.complexity.SetTitleOperation.Was == nil {
			break
		}

		return e.complexity.SetTitleOperation.Was(childComplexity), true

	case "SetTitlePayload.bug":
		if e.complexity.SetTitlePayload.Bug == nil {
			break
		}

		return e.complexity.SetTitlePayload.Bug(childComplexity), true

	case "SetTitlePayload.clientMutationId":
		if e.complexity.SetTitlePayload.ClientMutationID == nil {
			break
		}

		return e.complexity.SetTitlePayload.ClientMutationID(childComplexity), true

	case "SetTitlePayload.operation":
		if e.complexity.SetTitlePayload.Operation == nil {
			break
		}

		return e.complexity.SetTitlePayload.Operation(childComplexity), true

	case "SetTitleTimelineItem.author":
		if e.complexity.SetTitleTimelineItem.Author == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Author(childComplexity), true

	case "SetTitleTimelineItem.date":
		if e.complexity.SetTitleTimelineItem.Date == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Date(childComplexity), true

	case "SetTitleTimelineItem.id":
		if e.complexity.SetTitleTimelineItem.ID == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.ID(childComplexity), true

	case "SetTitleTimelineItem.title":
		if e.complexity.SetTitleTimelineItem.Title == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Title(childComplexity), true

	case "SetTitleTimelineItem.was":
		if e.complexity.SetTitleTimelineItem.Was == nil {
			break
		}

		return e.complexity.SetTitleTimelineItem.Was(childComplexity), true

	case "TimelineItemConnection.edges":
		if e.complexity.TimelineItemConnection.Edges == nil {
			break
		}

		return e.complexity.TimelineItemConnection.Edges(childComplexity), true

	case "TimelineItemConnection.nodes":
		if e.complexity.TimelineItemConnection.Nodes == nil {
			break
		}

		return e.complexity.TimelineItemConnection.Nodes(childComplexity), true

	case "TimelineItemConnection.pageInfo":
		if e.complexity.TimelineItemConnection.PageInfo == nil {
			break
		}

		return e.complexity.TimelineItemConnection.PageInfo(childComplexity), true

	case "TimelineItemConnection.totalCount":
		if e.complexity.TimelineItemConnection.TotalCount == nil {
			break
		}

		return e.complexity.TimelineItemConnection.TotalCount(childComplexity), true

	case "TimelineItemEdge.cursor":
		if e.complexity.TimelineItemEdge.Cursor == nil {
			break
		}

		return e.complexity.TimelineItemEdge.Cursor(childComplexity), true

	case "TimelineItemEdge.node":
		if e.complexity.TimelineItemEdge.Node == nil {
			break
		}

		return e.complexity.TimelineItemEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddCommentAndCloseBugInput,
		ec.unmarshalInputAddCommentAndReopenBugInput,
		ec.unmarshalInputAddCommentInput,
		ec.unmarshalInputChangeLabelInput,
		ec.unmarshalInputCloseBugInput,
		ec.unmarshalInputEditCommentInput,
		ec.unmarshalInputNewBugInput,
		ec.unmarshalInputOpenBugInput,
		ec.unmarshalInputSetTitleInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/bug.graphql", Input: `"""Represents a comment on a bug."""
type Comment implements Authored {
  id: CombinedId!

  """The author of this comment."""
  author: Identity!

  """The message of this comment."""
  message: String!

  """All media's hash referenced in this comment"""
  files: [Hash!]!
}

type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

enum Status {
  OPEN
  CLOSED
}

type Bug implements Authored {
  """The identifier for this bug"""
  id: ID!
  """The human version (truncated) identifier for this bug"""
  humanId: String!
  status: Status!
  title: String!
  labels: [Label!]!
  author: Identity!
  createdAt: Time!
  lastEdit: Time!

  """The actors of the bug. Actors are Identity that have interacted with the bug."""
  actors(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): IdentityConnection!

  """The participants of the bug. Participants are Identity that have created or
  added a comment on the bug."""
  participants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): IdentityConnection!

  comments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): CommentConnection!

  timeline(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): TimelineItemConnection!

  operations(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): OperationConnection!
}

"""The connection type for Bug."""
type BugConnection {
  """A list of edges."""
  edges: [BugEdge!]!
  nodes: [Bug!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type BugEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Bug!
}
`, BuiltIn: false},
	{Name: "../schema/identity.graphql", Input: `"""Represents an identity"""
type Identity {
    """The identifier for this identity"""
    id: ID!
    """The human version (truncated) identifier for this identity"""
    humanId: String!
    """The name of the person, if known."""
    name: String
    """The email of the person, if known."""
    email: String
    """The login of the person, if known."""
    login: String
    """A non-empty string to display, representing the identity, based on the non-empty values."""
    displayName: String!
    """An url to an avatar"""
    avatarUrl: String
    """isProtected is true if the chain of git commits started to be signed.
    If that's the case, only signed commit with a valid key for this identity can be added."""
    isProtected: Boolean!
}

type IdentityConnection {
    edges: [IdentityEdge!]!
    nodes: [Identity!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type IdentityEdge {
    cursor: String!
    node: Identity!
}`, BuiltIn: false},
	{Name: "../schema/label.graphql", Input: `"""Label for a bug."""
type Label {
    """The name of the label."""
    name: String!
    """Color of the label."""
    color: Color!
}

type LabelConnection {
    edges: [LabelEdge!]!
    nodes: [Label!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type LabelEdge {
    cursor: String!
    node: Label!
}`, BuiltIn: false},
	{Name: "../schema/mutations.graphql", Input: `input NewBugInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The title of the new bug."""
    title: String!
    """The first message of the new bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type NewBugPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The created bug."""
    bug: Bug!
    """The resulting operation."""
    operation: CreateOperation!
}

input AddCommentInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The message to be added to the bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type AddCommentPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: AddCommentOperation!
}

input AddCommentAndCloseBugInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The message to be added to the bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type AddCommentAndCloseBugPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting AddComment operation."""
    commentOperation: AddCommentOperation!
    """The resulting SetStatusOperation."""
    statusOperation: SetStatusOperation!
}

input AddCommentAndReopenBugInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The message to be added to the bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type AddCommentAndReopenBugPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting AddComment operation."""
    commentOperation: AddCommentOperation!
    """The resulting SetStatusOperation."""
    statusOperation: SetStatusOperation!
}

input EditCommentInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """A prefix of the CombinedId of the comment to be changed."""
    targetPrefix: String!
    """The new message to be set."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type EditCommentPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: EditCommentOperation!
}

input ChangeLabelInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The list of label to add."""
    added: [String!]
    """The list of label to remove."""
    Removed: [String!]
}

enum LabelChangeStatus {
    ADDED
    REMOVED
    DUPLICATE_IN_OP
    ALREADY_SET
    DOESNT_EXIST
}

type LabelChangeResult {
    """The source label."""
    label: Label!
    """The effect this label had."""
    status: LabelChangeStatus!
}

type ChangeLabelPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: LabelChangeOperation!
    """The effect each source label had."""
    results: [LabelChangeResult]!
}

input OpenBugInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
}

type OpenBugPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: SetStatusOperation!
}

input CloseBugInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
}

type CloseBugPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: SetStatusOperation!
}

input SetTitleInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The new title."""
    title: String!
}

type SetTitlePayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation"""
    operation: SetTitleOperation!
}
`, BuiltIn: false},
	{Name: "../schema/operations.graphql", Input: `"""An operation applied to a bug."""
interface Operation {
    """The identifier of the operation"""
    id: ID!
    """The operations author."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!
}

# Connection

"""The connection type for an Operation"""
type OperationConnection {
    edges: [OperationEdge!]!
    nodes: [Operation!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

"""Represent an Operation"""
type OperationEdge {
    cursor: String!
    node: Operation!
}

# Operations

type CreateOperation implements Operation & Authored {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!

    title: String!
    message: String!
    files: [Hash!]!
}

type SetTitleOperation implements Operation & Authored {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!

    title: String!
    was: String!
}

type AddCommentOperation implements Operation & Authored {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!

    message: String!
    files: [Hash!]!
}

type EditCommentOperation implements Operation & Authored {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!

    target: String!
    message: String!
    files: [Hash!]!
}

type SetStatusOperation implements Operation & Authored {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!

    status: Status!
}

type LabelChangeOperation implements Operation & Authored {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time!

    added: [Label!]!
    removed: [Label!]!
}
`, BuiltIn: false},
	{Name: "../schema/repository.graphql", Input: `
type Repository {
    """The name of the repository"""
    name: String

    """All the bugs"""
    allBugs(
        """Returns the elements in the list that come after the specified cursor."""
        after: String
        """Returns the elements in the list that come before the specified cursor."""
        before: String
        """Returns the first _n_ elements from the list."""
        first: Int
        """Returns the last _n_ elements from the list."""
        last: Int
        """A query to select and order bugs."""
        query: String
    ): BugConnection!

    bug(prefix: String!): Bug

    """All the identities"""
    allIdentities(
        """Returns the elements in the list that come after the specified cursor."""
        after: String
        """Returns the elements in the list that come before the specified cursor."""
        before: String
        """Returns the first _n_ elements from the list."""
        first: Int
        """Returns the last _n_ elements from the list."""
        last: Int
    ): IdentityConnection!

    identity(prefix: String!): Identity

    """The identity created or selected by the user as its own"""
    userIdentity: Identity

    """List of valid labels."""
    validLabels(
        """Returns the elements in the list that come after the specified cursor."""
        after: String
        """Returns the elements in the list that come before the specified cursor."""
        before: String
        """Returns the first _n_ elements from the list."""
        first: Int
        """Returns the last _n_ elements from the list."""
        last: Int
    ): LabelConnection!
}
`, BuiltIn: false},
	{Name: "../schema/root.graphql", Input: `type Query {
    """Access a repository by reference/name. If no ref is given, the default repository is returned if any."""
    repository(ref: String): Repository
}

type Mutation {
    """Create a new bug"""
    newBug(input: NewBugInput!): NewBugPayload!
    """Add a new comment to a bug"""
    addComment(input: AddCommentInput!): AddCommentPayload!
    """Add a new comment to a bug and close it"""
    addCommentAndClose(input: AddCommentAndCloseBugInput!): AddCommentAndCloseBugPayload!
    """Add a new comment to a bug and reopen it"""
    addCommentAndReopen(input: AddCommentAndReopenBugInput!): AddCommentAndReopenBugPayload!
    """Change a comment of a bug"""
    editComment(input: EditCommentInput!): EditCommentPayload!
    """Add or remove a set of label on a bug"""
    changeLabels(input: ChangeLabelInput): ChangeLabelPayload!
    """Change a bug's status to open"""
    openBug(input: OpenBugInput!): OpenBugPayload!
    """Change a bug's status to closed"""
    closeBug(input: CloseBugInput!): CloseBugPayload!
    """Change a bug's title"""
    setTitle(input: SetTitleInput!): SetTitlePayload!
}
`, BuiltIn: false},
	{Name: "../schema/timeline.graphql", Input: `"""An item in the timeline of events"""
interface TimelineItem {
    """The identifier of the source operation"""
    id: CombinedId!
}

"""CommentHistoryStep hold one version of a message in the history"""
type CommentHistoryStep {
    message: String!
    date: Time!
}

# Connection

"""The connection type for TimelineItem"""
type TimelineItemConnection {
    edges: [TimelineItemEdge!]!
    nodes: [TimelineItem!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

"""Represent a TimelineItem"""
type TimelineItemEdge {
    cursor: String!
    node: TimelineItem!
}

# Items

"""CreateTimelineItem is a TimelineItem that represent the creation of a bug and its message edition history"""
type CreateTimelineItem implements TimelineItem & Authored {
    """The identifier of the source operation"""
    id: CombinedId!
    author: Identity!
    message: String!
    messageIsEmpty: Boolean!
    files: [Hash!]!
    createdAt: Time!
    lastEdit: Time!
    edited: Boolean!
    history: [CommentHistoryStep!]!
}

"""AddCommentTimelineItem is a TimelineItem that represent a Comment and its edition history"""
type AddCommentTimelineItem implements TimelineItem & Authored {
    """The identifier of the source operation"""
    id: CombinedId!
    author: Identity!
    message: String!
    messageIsEmpty: Boolean!
    files: [Hash!]!
    createdAt: Time!
    lastEdit: Time!
    edited: Boolean!
    history: [CommentHistoryStep!]!
}

"""LabelChangeTimelineItem is a TimelineItem that represent a change in the labels of a bug"""
type LabelChangeTimelineItem implements TimelineItem & Authored {
    """The identifier of the source operation"""
    id: CombinedId!
    author: Identity!
    date: Time!
    added: [Label!]!
    removed: [Label!]!
}

"""SetStatusTimelineItem is a TimelineItem that represent a change in the status of a bug"""
type SetStatusTimelineItem implements TimelineItem & Authored {
    """The identifier of the source operation"""
    id: CombinedId!
    author: Identity!
    date: Time!
    status: Status!
}

"""LabelChangeTimelineItem is a TimelineItem that represent a change in the title of a bug"""
type SetTitleTimelineItem implements TimelineItem & Authored {
    """The identifier of the source operation"""
    id: CombinedId!
    author: Identity!
    date: Time!
    title: String!
    was: String!
}
`, BuiltIn: false},
	{Name: "../schema/types.graphql", Input: `scalar CombinedId
scalar Time
scalar Hash

"""Defines a color by red, green and blue components."""
type Color {
    """Red component of the color."""
    R: Int!
    """Green component of the color."""
    G: Int!
    """Blue component of the color."""
    B: Int!
}

"""Information about pagination in a connection."""
type PageInfo {
    """When paginating forwards, are there more items?"""
    hasNextPage: Boolean!
    """When paginating backwards, are there more items?"""
    hasPreviousPage: Boolean!
    """When paginating backwards, the cursor to continue."""
    startCursor: String!
    """When paginating forwards, the cursor to continue."""
    endCursor: String!
}

"""An object that has an author."""
interface Authored {
    """The author of this object."""
    author: Identity!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
