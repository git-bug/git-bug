// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/git-bug/git-bug/api/graphql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Bug() BugResolver
	BugAddCommentOperation() BugAddCommentOperationResolver
	BugAddCommentTimelineItem() BugAddCommentTimelineItemResolver
	BugComment() BugCommentResolver
	BugCommentHistoryStep() BugCommentHistoryStepResolver
	BugCreateOperation() BugCreateOperationResolver
	BugCreateTimelineItem() BugCreateTimelineItemResolver
	BugEditCommentOperation() BugEditCommentOperationResolver
	BugLabelChangeOperation() BugLabelChangeOperationResolver
	BugLabelChangeTimelineItem() BugLabelChangeTimelineItemResolver
	BugSetStatusOperation() BugSetStatusOperationResolver
	BugSetStatusTimelineItem() BugSetStatusTimelineItemResolver
	BugSetTitleOperation() BugSetTitleOperationResolver
	BugSetTitleTimelineItem() BugSetTitleTimelineItemResolver
	Color() ColorResolver
	Identity() IdentityResolver
	Label() LabelResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Bug struct {
		Actors       func(childComplexity int, after *string, before *string, first *int, last *int) int
		Author       func(childComplexity int) int
		Comments     func(childComplexity int, after *string, before *string, first *int, last *int) int
		CreatedAt    func(childComplexity int) int
		HumanID      func(childComplexity int) int
		Id           func(childComplexity int) int
		Labels       func(childComplexity int) int
		LastEdit     func(childComplexity int) int
		Operations   func(childComplexity int, after *string, before *string, first *int, last *int) int
		Participants func(childComplexity int, after *string, before *string, first *int, last *int) int
		Status       func(childComplexity int) int
		Timeline     func(childComplexity int, after *string, before *string, first *int, last *int) int
		Title        func(childComplexity int) int
	}

	BugAddCommentAndClosePayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		CommentOperation func(childComplexity int) int
		StatusOperation  func(childComplexity int) int
	}

	BugAddCommentAndReopenPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		CommentOperation func(childComplexity int) int
		StatusOperation  func(childComplexity int) int
	}

	BugAddCommentOperation struct {
		Author  func(childComplexity int) int
		Files   func(childComplexity int) int
		Id      func(childComplexity int) int
		Message func(childComplexity int) int
		Time    func(childComplexity int) int
	}

	BugAddCommentPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	BugAddCommentTimelineItem struct {
		Author         func(childComplexity int) int
		CombinedId     func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Edited         func(childComplexity int) int
		Files          func(childComplexity int) int
		History        func(childComplexity int) int
		LastEdit       func(childComplexity int) int
		Message        func(childComplexity int) int
		MessageIsEmpty func(childComplexity int) int
	}

	BugChangeLabelPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
		Results          func(childComplexity int) int
	}

	BugComment struct {
		Author     func(childComplexity int) int
		CombinedId func(childComplexity int) int
		Files      func(childComplexity int) int
		Message    func(childComplexity int) int
	}

	BugCommentConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BugCommentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BugCommentHistoryStep struct {
		Date    func(childComplexity int) int
		Message func(childComplexity int) int
	}

	BugConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BugCreateOperation struct {
		Author  func(childComplexity int) int
		Files   func(childComplexity int) int
		Id      func(childComplexity int) int
		Message func(childComplexity int) int
		Time    func(childComplexity int) int
		Title   func(childComplexity int) int
	}

	BugCreatePayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	BugCreateTimelineItem struct {
		Author         func(childComplexity int) int
		CombinedId     func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Edited         func(childComplexity int) int
		Files          func(childComplexity int) int
		History        func(childComplexity int) int
		LastEdit       func(childComplexity int) int
		Message        func(childComplexity int) int
		MessageIsEmpty func(childComplexity int) int
	}

	BugEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BugEditCommentOperation struct {
		Author  func(childComplexity int) int
		Files   func(childComplexity int) int
		Id      func(childComplexity int) int
		Message func(childComplexity int) int
		Target  func(childComplexity int) int
		Time    func(childComplexity int) int
	}

	BugEditCommentPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	BugLabelChangeOperation struct {
		Added   func(childComplexity int) int
		Author  func(childComplexity int) int
		Id      func(childComplexity int) int
		Removed func(childComplexity int) int
		Time    func(childComplexity int) int
	}

	BugLabelChangeTimelineItem struct {
		Added      func(childComplexity int) int
		Author     func(childComplexity int) int
		CombinedId func(childComplexity int) int
		Date       func(childComplexity int) int
		Removed    func(childComplexity int) int
	}

	BugSetStatusOperation struct {
		Author func(childComplexity int) int
		Id     func(childComplexity int) int
		Status func(childComplexity int) int
		Time   func(childComplexity int) int
	}

	BugSetStatusTimelineItem struct {
		Author     func(childComplexity int) int
		CombinedId func(childComplexity int) int
		Date       func(childComplexity int) int
		Status     func(childComplexity int) int
	}

	BugSetTitleOperation struct {
		Author func(childComplexity int) int
		Id     func(childComplexity int) int
		Time   func(childComplexity int) int
		Title  func(childComplexity int) int
		Was    func(childComplexity int) int
	}

	BugSetTitlePayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	BugSetTitleTimelineItem struct {
		Author     func(childComplexity int) int
		CombinedId func(childComplexity int) int
		Date       func(childComplexity int) int
		Title      func(childComplexity int) int
		Was        func(childComplexity int) int
	}

	BugStatusClosePayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	BugStatusOpenPayload struct {
		Bug              func(childComplexity int) int
		ClientMutationID func(childComplexity int) int
		Operation        func(childComplexity int) int
	}

	BugTimelineItemConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BugTimelineItemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Color struct {
		B func(childComplexity int) int
		G func(childComplexity int) int
		R func(childComplexity int) int
	}

	Identity struct {
		AvatarUrl   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		HumanID     func(childComplexity int) int
		Id          func(childComplexity int) int
		IsProtected func(childComplexity int) int
		Login       func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	IdentityConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IdentityEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Label struct {
		Color func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	LabelChangeResult struct {
		Label  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	LabelConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LabelEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		BugAddComment          func(childComplexity int, input models.BugAddCommentInput) int
		BugAddCommentAndClose  func(childComplexity int, input models.BugAddCommentAndCloseInput) int
		BugAddCommentAndReopen func(childComplexity int, input models.BugAddCommentAndReopenInput) int
		BugChangeLabels        func(childComplexity int, input *models.BugChangeLabelInput) int
		BugCreate              func(childComplexity int, input models.BugCreateInput) int
		BugEditComment         func(childComplexity int, input models.BugEditCommentInput) int
		BugSetTitle            func(childComplexity int, input models.BugSetTitleInput) int
		BugStatusClose         func(childComplexity int, input models.BugStatusCloseInput) int
		BugStatusOpen          func(childComplexity int, input models.BugStatusOpenInput) int
	}

	OperationConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OperationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Repository func(childComplexity int, ref *string) int
	}

	Repository struct {
		AllBugs       func(childComplexity int, after *string, before *string, first *int, last *int, query *string) int
		AllIdentities func(childComplexity int, after *string, before *string, first *int, last *int) int
		Bug           func(childComplexity int, prefix string) int
		Identity      func(childComplexity int, prefix string) int
		Name          func(childComplexity int) int
		UserIdentity  func(childComplexity int) int
		ValidLabels   func(childComplexity int, after *string, before *string, first *int, last *int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Bug.actors":
		if e.complexity.Bug.Actors == nil {
			break
		}

		args, err := ec.field_Bug_actors_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Actors(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.author":
		if e.complexity.Bug.Author == nil {
			break
		}

		return e.complexity.Bug.Author(childComplexity), true

	case "Bug.comments":
		if e.complexity.Bug.Comments == nil {
			break
		}

		args, err := ec.field_Bug_comments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Comments(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.createdAt":
		if e.complexity.Bug.CreatedAt == nil {
			break
		}

		return e.complexity.Bug.CreatedAt(childComplexity), true

	case "Bug.humanId":
		if e.complexity.Bug.HumanID == nil {
			break
		}

		return e.complexity.Bug.HumanID(childComplexity), true

	case "Bug.id":
		if e.complexity.Bug.Id == nil {
			break
		}

		return e.complexity.Bug.Id(childComplexity), true

	case "Bug.labels":
		if e.complexity.Bug.Labels == nil {
			break
		}

		return e.complexity.Bug.Labels(childComplexity), true

	case "Bug.lastEdit":
		if e.complexity.Bug.LastEdit == nil {
			break
		}

		return e.complexity.Bug.LastEdit(childComplexity), true

	case "Bug.operations":
		if e.complexity.Bug.Operations == nil {
			break
		}

		args, err := ec.field_Bug_operations_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Operations(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.participants":
		if e.complexity.Bug.Participants == nil {
			break
		}

		args, err := ec.field_Bug_participants_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Participants(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.status":
		if e.complexity.Bug.Status == nil {
			break
		}

		return e.complexity.Bug.Status(childComplexity), true

	case "Bug.timeline":
		if e.complexity.Bug.Timeline == nil {
			break
		}

		args, err := ec.field_Bug_timeline_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bug.Timeline(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Bug.title":
		if e.complexity.Bug.Title == nil {
			break
		}

		return e.complexity.Bug.Title(childComplexity), true

	case "BugAddCommentAndClosePayload.bug":
		if e.complexity.BugAddCommentAndClosePayload.Bug == nil {
			break
		}

		return e.complexity.BugAddCommentAndClosePayload.Bug(childComplexity), true

	case "BugAddCommentAndClosePayload.clientMutationId":
		if e.complexity.BugAddCommentAndClosePayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugAddCommentAndClosePayload.ClientMutationID(childComplexity), true

	case "BugAddCommentAndClosePayload.commentOperation":
		if e.complexity.BugAddCommentAndClosePayload.CommentOperation == nil {
			break
		}

		return e.complexity.BugAddCommentAndClosePayload.CommentOperation(childComplexity), true

	case "BugAddCommentAndClosePayload.statusOperation":
		if e.complexity.BugAddCommentAndClosePayload.StatusOperation == nil {
			break
		}

		return e.complexity.BugAddCommentAndClosePayload.StatusOperation(childComplexity), true

	case "BugAddCommentAndReopenPayload.bug":
		if e.complexity.BugAddCommentAndReopenPayload.Bug == nil {
			break
		}

		return e.complexity.BugAddCommentAndReopenPayload.Bug(childComplexity), true

	case "BugAddCommentAndReopenPayload.clientMutationId":
		if e.complexity.BugAddCommentAndReopenPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugAddCommentAndReopenPayload.ClientMutationID(childComplexity), true

	case "BugAddCommentAndReopenPayload.commentOperation":
		if e.complexity.BugAddCommentAndReopenPayload.CommentOperation == nil {
			break
		}

		return e.complexity.BugAddCommentAndReopenPayload.CommentOperation(childComplexity), true

	case "BugAddCommentAndReopenPayload.statusOperation":
		if e.complexity.BugAddCommentAndReopenPayload.StatusOperation == nil {
			break
		}

		return e.complexity.BugAddCommentAndReopenPayload.StatusOperation(childComplexity), true

	case "BugAddCommentOperation.author":
		if e.complexity.BugAddCommentOperation.Author == nil {
			break
		}

		return e.complexity.BugAddCommentOperation.Author(childComplexity), true

	case "BugAddCommentOperation.files":
		if e.complexity.BugAddCommentOperation.Files == nil {
			break
		}

		return e.complexity.BugAddCommentOperation.Files(childComplexity), true

	case "BugAddCommentOperation.id":
		if e.complexity.BugAddCommentOperation.Id == nil {
			break
		}

		return e.complexity.BugAddCommentOperation.Id(childComplexity), true

	case "BugAddCommentOperation.message":
		if e.complexity.BugAddCommentOperation.Message == nil {
			break
		}

		return e.complexity.BugAddCommentOperation.Message(childComplexity), true

	case "BugAddCommentOperation.date":
		if e.complexity.BugAddCommentOperation.Time == nil {
			break
		}

		return e.complexity.BugAddCommentOperation.Time(childComplexity), true

	case "BugAddCommentPayload.bug":
		if e.complexity.BugAddCommentPayload.Bug == nil {
			break
		}

		return e.complexity.BugAddCommentPayload.Bug(childComplexity), true

	case "BugAddCommentPayload.clientMutationId":
		if e.complexity.BugAddCommentPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugAddCommentPayload.ClientMutationID(childComplexity), true

	case "BugAddCommentPayload.operation":
		if e.complexity.BugAddCommentPayload.Operation == nil {
			break
		}

		return e.complexity.BugAddCommentPayload.Operation(childComplexity), true

	case "BugAddCommentTimelineItem.author":
		if e.complexity.BugAddCommentTimelineItem.Author == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.Author(childComplexity), true

	case "BugAddCommentTimelineItem.id":
		if e.complexity.BugAddCommentTimelineItem.CombinedId == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.CombinedId(childComplexity), true

	case "BugAddCommentTimelineItem.createdAt":
		if e.complexity.BugAddCommentTimelineItem.CreatedAt == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.CreatedAt(childComplexity), true

	case "BugAddCommentTimelineItem.edited":
		if e.complexity.BugAddCommentTimelineItem.Edited == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.Edited(childComplexity), true

	case "BugAddCommentTimelineItem.files":
		if e.complexity.BugAddCommentTimelineItem.Files == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.Files(childComplexity), true

	case "BugAddCommentTimelineItem.history":
		if e.complexity.BugAddCommentTimelineItem.History == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.History(childComplexity), true

	case "BugAddCommentTimelineItem.lastEdit":
		if e.complexity.BugAddCommentTimelineItem.LastEdit == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.LastEdit(childComplexity), true

	case "BugAddCommentTimelineItem.message":
		if e.complexity.BugAddCommentTimelineItem.Message == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.Message(childComplexity), true

	case "BugAddCommentTimelineItem.messageIsEmpty":
		if e.complexity.BugAddCommentTimelineItem.MessageIsEmpty == nil {
			break
		}

		return e.complexity.BugAddCommentTimelineItem.MessageIsEmpty(childComplexity), true

	case "BugChangeLabelPayload.bug":
		if e.complexity.BugChangeLabelPayload.Bug == nil {
			break
		}

		return e.complexity.BugChangeLabelPayload.Bug(childComplexity), true

	case "BugChangeLabelPayload.clientMutationId":
		if e.complexity.BugChangeLabelPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugChangeLabelPayload.ClientMutationID(childComplexity), true

	case "BugChangeLabelPayload.operation":
		if e.complexity.BugChangeLabelPayload.Operation == nil {
			break
		}

		return e.complexity.BugChangeLabelPayload.Operation(childComplexity), true

	case "BugChangeLabelPayload.results":
		if e.complexity.BugChangeLabelPayload.Results == nil {
			break
		}

		return e.complexity.BugChangeLabelPayload.Results(childComplexity), true

	case "BugComment.author":
		if e.complexity.BugComment.Author == nil {
			break
		}

		return e.complexity.BugComment.Author(childComplexity), true

	case "BugComment.id":
		if e.complexity.BugComment.CombinedId == nil {
			break
		}

		return e.complexity.BugComment.CombinedId(childComplexity), true

	case "BugComment.files":
		if e.complexity.BugComment.Files == nil {
			break
		}

		return e.complexity.BugComment.Files(childComplexity), true

	case "BugComment.message":
		if e.complexity.BugComment.Message == nil {
			break
		}

		return e.complexity.BugComment.Message(childComplexity), true

	case "BugCommentConnection.edges":
		if e.complexity.BugCommentConnection.Edges == nil {
			break
		}

		return e.complexity.BugCommentConnection.Edges(childComplexity), true

	case "BugCommentConnection.nodes":
		if e.complexity.BugCommentConnection.Nodes == nil {
			break
		}

		return e.complexity.BugCommentConnection.Nodes(childComplexity), true

	case "BugCommentConnection.pageInfo":
		if e.complexity.BugCommentConnection.PageInfo == nil {
			break
		}

		return e.complexity.BugCommentConnection.PageInfo(childComplexity), true

	case "BugCommentConnection.totalCount":
		if e.complexity.BugCommentConnection.TotalCount == nil {
			break
		}

		return e.complexity.BugCommentConnection.TotalCount(childComplexity), true

	case "BugCommentEdge.cursor":
		if e.complexity.BugCommentEdge.Cursor == nil {
			break
		}

		return e.complexity.BugCommentEdge.Cursor(childComplexity), true

	case "BugCommentEdge.node":
		if e.complexity.BugCommentEdge.Node == nil {
			break
		}

		return e.complexity.BugCommentEdge.Node(childComplexity), true

	case "BugCommentHistoryStep.date":
		if e.complexity.BugCommentHistoryStep.Date == nil {
			break
		}

		return e.complexity.BugCommentHistoryStep.Date(childComplexity), true

	case "BugCommentHistoryStep.message":
		if e.complexity.BugCommentHistoryStep.Message == nil {
			break
		}

		return e.complexity.BugCommentHistoryStep.Message(childComplexity), true

	case "BugConnection.edges":
		if e.complexity.BugConnection.Edges == nil {
			break
		}

		return e.complexity.BugConnection.Edges(childComplexity), true

	case "BugConnection.nodes":
		if e.complexity.BugConnection.Nodes == nil {
			break
		}

		return e.complexity.BugConnection.Nodes(childComplexity), true

	case "BugConnection.pageInfo":
		if e.complexity.BugConnection.PageInfo == nil {
			break
		}

		return e.complexity.BugConnection.PageInfo(childComplexity), true

	case "BugConnection.totalCount":
		if e.complexity.BugConnection.TotalCount == nil {
			break
		}

		return e.complexity.BugConnection.TotalCount(childComplexity), true

	case "BugCreateOperation.author":
		if e.complexity.BugCreateOperation.Author == nil {
			break
		}

		return e.complexity.BugCreateOperation.Author(childComplexity), true

	case "BugCreateOperation.files":
		if e.complexity.BugCreateOperation.Files == nil {
			break
		}

		return e.complexity.BugCreateOperation.Files(childComplexity), true

	case "BugCreateOperation.id":
		if e.complexity.BugCreateOperation.Id == nil {
			break
		}

		return e.complexity.BugCreateOperation.Id(childComplexity), true

	case "BugCreateOperation.message":
		if e.complexity.BugCreateOperation.Message == nil {
			break
		}

		return e.complexity.BugCreateOperation.Message(childComplexity), true

	case "BugCreateOperation.date":
		if e.complexity.BugCreateOperation.Time == nil {
			break
		}

		return e.complexity.BugCreateOperation.Time(childComplexity), true

	case "BugCreateOperation.title":
		if e.complexity.BugCreateOperation.Title == nil {
			break
		}

		return e.complexity.BugCreateOperation.Title(childComplexity), true

	case "BugCreatePayload.bug":
		if e.complexity.BugCreatePayload.Bug == nil {
			break
		}

		return e.complexity.BugCreatePayload.Bug(childComplexity), true

	case "BugCreatePayload.clientMutationId":
		if e.complexity.BugCreatePayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugCreatePayload.ClientMutationID(childComplexity), true

	case "BugCreatePayload.operation":
		if e.complexity.BugCreatePayload.Operation == nil {
			break
		}

		return e.complexity.BugCreatePayload.Operation(childComplexity), true

	case "BugCreateTimelineItem.author":
		if e.complexity.BugCreateTimelineItem.Author == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.Author(childComplexity), true

	case "BugCreateTimelineItem.id":
		if e.complexity.BugCreateTimelineItem.CombinedId == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.CombinedId(childComplexity), true

	case "BugCreateTimelineItem.createdAt":
		if e.complexity.BugCreateTimelineItem.CreatedAt == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.CreatedAt(childComplexity), true

	case "BugCreateTimelineItem.edited":
		if e.complexity.BugCreateTimelineItem.Edited == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.Edited(childComplexity), true

	case "BugCreateTimelineItem.files":
		if e.complexity.BugCreateTimelineItem.Files == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.Files(childComplexity), true

	case "BugCreateTimelineItem.history":
		if e.complexity.BugCreateTimelineItem.History == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.History(childComplexity), true

	case "BugCreateTimelineItem.lastEdit":
		if e.complexity.BugCreateTimelineItem.LastEdit == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.LastEdit(childComplexity), true

	case "BugCreateTimelineItem.message":
		if e.complexity.BugCreateTimelineItem.Message == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.Message(childComplexity), true

	case "BugCreateTimelineItem.messageIsEmpty":
		if e.complexity.BugCreateTimelineItem.MessageIsEmpty == nil {
			break
		}

		return e.complexity.BugCreateTimelineItem.MessageIsEmpty(childComplexity), true

	case "BugEdge.cursor":
		if e.complexity.BugEdge.Cursor == nil {
			break
		}

		return e.complexity.BugEdge.Cursor(childComplexity), true

	case "BugEdge.node":
		if e.complexity.BugEdge.Node == nil {
			break
		}

		return e.complexity.BugEdge.Node(childComplexity), true

	case "BugEditCommentOperation.author":
		if e.complexity.BugEditCommentOperation.Author == nil {
			break
		}

		return e.complexity.BugEditCommentOperation.Author(childComplexity), true

	case "BugEditCommentOperation.files":
		if e.complexity.BugEditCommentOperation.Files == nil {
			break
		}

		return e.complexity.BugEditCommentOperation.Files(childComplexity), true

	case "BugEditCommentOperation.id":
		if e.complexity.BugEditCommentOperation.Id == nil {
			break
		}

		return e.complexity.BugEditCommentOperation.Id(childComplexity), true

	case "BugEditCommentOperation.message":
		if e.complexity.BugEditCommentOperation.Message == nil {
			break
		}

		return e.complexity.BugEditCommentOperation.Message(childComplexity), true

	case "BugEditCommentOperation.target":
		if e.complexity.BugEditCommentOperation.Target == nil {
			break
		}

		return e.complexity.BugEditCommentOperation.Target(childComplexity), true

	case "BugEditCommentOperation.date":
		if e.complexity.BugEditCommentOperation.Time == nil {
			break
		}

		return e.complexity.BugEditCommentOperation.Time(childComplexity), true

	case "BugEditCommentPayload.bug":
		if e.complexity.BugEditCommentPayload.Bug == nil {
			break
		}

		return e.complexity.BugEditCommentPayload.Bug(childComplexity), true

	case "BugEditCommentPayload.clientMutationId":
		if e.complexity.BugEditCommentPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugEditCommentPayload.ClientMutationID(childComplexity), true

	case "BugEditCommentPayload.operation":
		if e.complexity.BugEditCommentPayload.Operation == nil {
			break
		}

		return e.complexity.BugEditCommentPayload.Operation(childComplexity), true

	case "BugLabelChangeOperation.added":
		if e.complexity.BugLabelChangeOperation.Added == nil {
			break
		}

		return e.complexity.BugLabelChangeOperation.Added(childComplexity), true

	case "BugLabelChangeOperation.author":
		if e.complexity.BugLabelChangeOperation.Author == nil {
			break
		}

		return e.complexity.BugLabelChangeOperation.Author(childComplexity), true

	case "BugLabelChangeOperation.id":
		if e.complexity.BugLabelChangeOperation.Id == nil {
			break
		}

		return e.complexity.BugLabelChangeOperation.Id(childComplexity), true

	case "BugLabelChangeOperation.removed":
		if e.complexity.BugLabelChangeOperation.Removed == nil {
			break
		}

		return e.complexity.BugLabelChangeOperation.Removed(childComplexity), true

	case "BugLabelChangeOperation.date":
		if e.complexity.BugLabelChangeOperation.Time == nil {
			break
		}

		return e.complexity.BugLabelChangeOperation.Time(childComplexity), true

	case "BugLabelChangeTimelineItem.added":
		if e.complexity.BugLabelChangeTimelineItem.Added == nil {
			break
		}

		return e.complexity.BugLabelChangeTimelineItem.Added(childComplexity), true

	case "BugLabelChangeTimelineItem.author":
		if e.complexity.BugLabelChangeTimelineItem.Author == nil {
			break
		}

		return e.complexity.BugLabelChangeTimelineItem.Author(childComplexity), true

	case "BugLabelChangeTimelineItem.id":
		if e.complexity.BugLabelChangeTimelineItem.CombinedId == nil {
			break
		}

		return e.complexity.BugLabelChangeTimelineItem.CombinedId(childComplexity), true

	case "BugLabelChangeTimelineItem.date":
		if e.complexity.BugLabelChangeTimelineItem.Date == nil {
			break
		}

		return e.complexity.BugLabelChangeTimelineItem.Date(childComplexity), true

	case "BugLabelChangeTimelineItem.removed":
		if e.complexity.BugLabelChangeTimelineItem.Removed == nil {
			break
		}

		return e.complexity.BugLabelChangeTimelineItem.Removed(childComplexity), true

	case "BugSetStatusOperation.author":
		if e.complexity.BugSetStatusOperation.Author == nil {
			break
		}

		return e.complexity.BugSetStatusOperation.Author(childComplexity), true

	case "BugSetStatusOperation.id":
		if e.complexity.BugSetStatusOperation.Id == nil {
			break
		}

		return e.complexity.BugSetStatusOperation.Id(childComplexity), true

	case "BugSetStatusOperation.status":
		if e.complexity.BugSetStatusOperation.Status == nil {
			break
		}

		return e.complexity.BugSetStatusOperation.Status(childComplexity), true

	case "BugSetStatusOperation.date":
		if e.complexity.BugSetStatusOperation.Time == nil {
			break
		}

		return e.complexity.BugSetStatusOperation.Time(childComplexity), true

	case "BugSetStatusTimelineItem.author":
		if e.complexity.BugSetStatusTimelineItem.Author == nil {
			break
		}

		return e.complexity.BugSetStatusTimelineItem.Author(childComplexity), true

	case "BugSetStatusTimelineItem.id":
		if e.complexity.BugSetStatusTimelineItem.CombinedId == nil {
			break
		}

		return e.complexity.BugSetStatusTimelineItem.CombinedId(childComplexity), true

	case "BugSetStatusTimelineItem.date":
		if e.complexity.BugSetStatusTimelineItem.Date == nil {
			break
		}

		return e.complexity.BugSetStatusTimelineItem.Date(childComplexity), true

	case "BugSetStatusTimelineItem.status":
		if e.complexity.BugSetStatusTimelineItem.Status == nil {
			break
		}

		return e.complexity.BugSetStatusTimelineItem.Status(childComplexity), true

	case "BugSetTitleOperation.author":
		if e.complexity.BugSetTitleOperation.Author == nil {
			break
		}

		return e.complexity.BugSetTitleOperation.Author(childComplexity), true

	case "BugSetTitleOperation.id":
		if e.complexity.BugSetTitleOperation.Id == nil {
			break
		}

		return e.complexity.BugSetTitleOperation.Id(childComplexity), true

	case "BugSetTitleOperation.date":
		if e.complexity.BugSetTitleOperation.Time == nil {
			break
		}

		return e.complexity.BugSetTitleOperation.Time(childComplexity), true

	case "BugSetTitleOperation.title":
		if e.complexity.BugSetTitleOperation.Title == nil {
			break
		}

		return e.complexity.BugSetTitleOperation.Title(childComplexity), true

	case "BugSetTitleOperation.was":
		if e.complexity.BugSetTitleOperation.Was == nil {
			break
		}

		return e.complexity.BugSetTitleOperation.Was(childComplexity), true

	case "BugSetTitlePayload.bug":
		if e.complexity.BugSetTitlePayload.Bug == nil {
			break
		}

		return e.complexity.BugSetTitlePayload.Bug(childComplexity), true

	case "BugSetTitlePayload.clientMutationId":
		if e.complexity.BugSetTitlePayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugSetTitlePayload.ClientMutationID(childComplexity), true

	case "BugSetTitlePayload.operation":
		if e.complexity.BugSetTitlePayload.Operation == nil {
			break
		}

		return e.complexity.BugSetTitlePayload.Operation(childComplexity), true

	case "BugSetTitleTimelineItem.author":
		if e.complexity.BugSetTitleTimelineItem.Author == nil {
			break
		}

		return e.complexity.BugSetTitleTimelineItem.Author(childComplexity), true

	case "BugSetTitleTimelineItem.id":
		if e.complexity.BugSetTitleTimelineItem.CombinedId == nil {
			break
		}

		return e.complexity.BugSetTitleTimelineItem.CombinedId(childComplexity), true

	case "BugSetTitleTimelineItem.date":
		if e.complexity.BugSetTitleTimelineItem.Date == nil {
			break
		}

		return e.complexity.BugSetTitleTimelineItem.Date(childComplexity), true

	case "BugSetTitleTimelineItem.title":
		if e.complexity.BugSetTitleTimelineItem.Title == nil {
			break
		}

		return e.complexity.BugSetTitleTimelineItem.Title(childComplexity), true

	case "BugSetTitleTimelineItem.was":
		if e.complexity.BugSetTitleTimelineItem.Was == nil {
			break
		}

		return e.complexity.BugSetTitleTimelineItem.Was(childComplexity), true

	case "BugStatusClosePayload.bug":
		if e.complexity.BugStatusClosePayload.Bug == nil {
			break
		}

		return e.complexity.BugStatusClosePayload.Bug(childComplexity), true

	case "BugStatusClosePayload.clientMutationId":
		if e.complexity.BugStatusClosePayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugStatusClosePayload.ClientMutationID(childComplexity), true

	case "BugStatusClosePayload.operation":
		if e.complexity.BugStatusClosePayload.Operation == nil {
			break
		}

		return e.complexity.BugStatusClosePayload.Operation(childComplexity), true

	case "BugStatusOpenPayload.bug":
		if e.complexity.BugStatusOpenPayload.Bug == nil {
			break
		}

		return e.complexity.BugStatusOpenPayload.Bug(childComplexity), true

	case "BugStatusOpenPayload.clientMutationId":
		if e.complexity.BugStatusOpenPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.BugStatusOpenPayload.ClientMutationID(childComplexity), true

	case "BugStatusOpenPayload.operation":
		if e.complexity.BugStatusOpenPayload.Operation == nil {
			break
		}

		return e.complexity.BugStatusOpenPayload.Operation(childComplexity), true

	case "BugTimelineItemConnection.edges":
		if e.complexity.BugTimelineItemConnection.Edges == nil {
			break
		}

		return e.complexity.BugTimelineItemConnection.Edges(childComplexity), true

	case "BugTimelineItemConnection.nodes":
		if e.complexity.BugTimelineItemConnection.Nodes == nil {
			break
		}

		return e.complexity.BugTimelineItemConnection.Nodes(childComplexity), true

	case "BugTimelineItemConnection.pageInfo":
		if e.complexity.BugTimelineItemConnection.PageInfo == nil {
			break
		}

		return e.complexity.BugTimelineItemConnection.PageInfo(childComplexity), true

	case "BugTimelineItemConnection.totalCount":
		if e.complexity.BugTimelineItemConnection.TotalCount == nil {
			break
		}

		return e.complexity.BugTimelineItemConnection.TotalCount(childComplexity), true

	case "BugTimelineItemEdge.cursor":
		if e.complexity.BugTimelineItemEdge.Cursor == nil {
			break
		}

		return e.complexity.BugTimelineItemEdge.Cursor(childComplexity), true

	case "BugTimelineItemEdge.node":
		if e.complexity.BugTimelineItemEdge.Node == nil {
			break
		}

		return e.complexity.BugTimelineItemEdge.Node(childComplexity), true

	case "Color.B":
		if e.complexity.Color.B == nil {
			break
		}

		return e.complexity.Color.B(childComplexity), true

	case "Color.G":
		if e.complexity.Color.G == nil {
			break
		}

		return e.complexity.Color.G(childComplexity), true

	case "Color.R":
		if e.complexity.Color.R == nil {
			break
		}

		return e.complexity.Color.R(childComplexity), true

	case "Identity.avatarUrl":
		if e.complexity.Identity.AvatarUrl == nil {
			break
		}

		return e.complexity.Identity.AvatarUrl(childComplexity), true

	case "Identity.displayName":
		if e.complexity.Identity.DisplayName == nil {
			break
		}

		return e.complexity.Identity.DisplayName(childComplexity), true

	case "Identity.email":
		if e.complexity.Identity.Email == nil {
			break
		}

		return e.complexity.Identity.Email(childComplexity), true

	case "Identity.humanId":
		if e.complexity.Identity.HumanID == nil {
			break
		}

		return e.complexity.Identity.HumanID(childComplexity), true

	case "Identity.id":
		if e.complexity.Identity.Id == nil {
			break
		}

		return e.complexity.Identity.Id(childComplexity), true

	case "Identity.isProtected":
		if e.complexity.Identity.IsProtected == nil {
			break
		}

		return e.complexity.Identity.IsProtected(childComplexity), true

	case "Identity.login":
		if e.complexity.Identity.Login == nil {
			break
		}

		return e.complexity.Identity.Login(childComplexity), true

	case "Identity.name":
		if e.complexity.Identity.Name == nil {
			break
		}

		return e.complexity.Identity.Name(childComplexity), true

	case "IdentityConnection.edges":
		if e.complexity.IdentityConnection.Edges == nil {
			break
		}

		return e.complexity.IdentityConnection.Edges(childComplexity), true

	case "IdentityConnection.nodes":
		if e.complexity.IdentityConnection.Nodes == nil {
			break
		}

		return e.complexity.IdentityConnection.Nodes(childComplexity), true

	case "IdentityConnection.pageInfo":
		if e.complexity.IdentityConnection.PageInfo == nil {
			break
		}

		return e.complexity.IdentityConnection.PageInfo(childComplexity), true

	case "IdentityConnection.totalCount":
		if e.complexity.IdentityConnection.TotalCount == nil {
			break
		}

		return e.complexity.IdentityConnection.TotalCount(childComplexity), true

	case "IdentityEdge.cursor":
		if e.complexity.IdentityEdge.Cursor == nil {
			break
		}

		return e.complexity.IdentityEdge.Cursor(childComplexity), true

	case "IdentityEdge.node":
		if e.complexity.IdentityEdge.Node == nil {
			break
		}

		return e.complexity.IdentityEdge.Node(childComplexity), true

	case "Label.color":
		if e.complexity.Label.Color == nil {
			break
		}

		return e.complexity.Label.Color(childComplexity), true

	case "Label.name":
		if e.complexity.Label.Name == nil {
			break
		}

		return e.complexity.Label.Name(childComplexity), true

	case "LabelChangeResult.label":
		if e.complexity.LabelChangeResult.Label == nil {
			break
		}

		return e.complexity.LabelChangeResult.Label(childComplexity), true

	case "LabelChangeResult.status":
		if e.complexity.LabelChangeResult.Status == nil {
			break
		}

		return e.complexity.LabelChangeResult.Status(childComplexity), true

	case "LabelConnection.edges":
		if e.complexity.LabelConnection.Edges == nil {
			break
		}

		return e.complexity.LabelConnection.Edges(childComplexity), true

	case "LabelConnection.nodes":
		if e.complexity.LabelConnection.Nodes == nil {
			break
		}

		return e.complexity.LabelConnection.Nodes(childComplexity), true

	case "LabelConnection.pageInfo":
		if e.complexity.LabelConnection.PageInfo == nil {
			break
		}

		return e.complexity.LabelConnection.PageInfo(childComplexity), true

	case "LabelConnection.totalCount":
		if e.complexity.LabelConnection.TotalCount == nil {
			break
		}

		return e.complexity.LabelConnection.TotalCount(childComplexity), true

	case "LabelEdge.cursor":
		if e.complexity.LabelEdge.Cursor == nil {
			break
		}

		return e.complexity.LabelEdge.Cursor(childComplexity), true

	case "LabelEdge.node":
		if e.complexity.LabelEdge.Node == nil {
			break
		}

		return e.complexity.LabelEdge.Node(childComplexity), true

	case "Mutation.bugAddComment":
		if e.complexity.Mutation.BugAddComment == nil {
			break
		}

		args, err := ec.field_Mutation_bugAddComment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugAddComment(childComplexity, args["input"].(models.BugAddCommentInput)), true

	case "Mutation.bugAddCommentAndClose":
		if e.complexity.Mutation.BugAddCommentAndClose == nil {
			break
		}

		args, err := ec.field_Mutation_bugAddCommentAndClose_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugAddCommentAndClose(childComplexity, args["input"].(models.BugAddCommentAndCloseInput)), true

	case "Mutation.bugAddCommentAndReopen":
		if e.complexity.Mutation.BugAddCommentAndReopen == nil {
			break
		}

		args, err := ec.field_Mutation_bugAddCommentAndReopen_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugAddCommentAndReopen(childComplexity, args["input"].(models.BugAddCommentAndReopenInput)), true

	case "Mutation.bugChangeLabels":
		if e.complexity.Mutation.BugChangeLabels == nil {
			break
		}

		args, err := ec.field_Mutation_bugChangeLabels_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugChangeLabels(childComplexity, args["input"].(*models.BugChangeLabelInput)), true

	case "Mutation.bugCreate":
		if e.complexity.Mutation.BugCreate == nil {
			break
		}

		args, err := ec.field_Mutation_bugCreate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugCreate(childComplexity, args["input"].(models.BugCreateInput)), true

	case "Mutation.bugEditComment":
		if e.complexity.Mutation.BugEditComment == nil {
			break
		}

		args, err := ec.field_Mutation_bugEditComment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugEditComment(childComplexity, args["input"].(models.BugEditCommentInput)), true

	case "Mutation.bugSetTitle":
		if e.complexity.Mutation.BugSetTitle == nil {
			break
		}

		args, err := ec.field_Mutation_bugSetTitle_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugSetTitle(childComplexity, args["input"].(models.BugSetTitleInput)), true

	case "Mutation.bugStatusClose":
		if e.complexity.Mutation.BugStatusClose == nil {
			break
		}

		args, err := ec.field_Mutation_bugStatusClose_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugStatusClose(childComplexity, args["input"].(models.BugStatusCloseInput)), true

	case "Mutation.bugStatusOpen":
		if e.complexity.Mutation.BugStatusOpen == nil {
			break
		}

		args, err := ec.field_Mutation_bugStatusOpen_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BugStatusOpen(childComplexity, args["input"].(models.BugStatusOpenInput)), true

	case "OperationConnection.edges":
		if e.complexity.OperationConnection.Edges == nil {
			break
		}

		return e.complexity.OperationConnection.Edges(childComplexity), true

	case "OperationConnection.nodes":
		if e.complexity.OperationConnection.Nodes == nil {
			break
		}

		return e.complexity.OperationConnection.Nodes(childComplexity), true

	case "OperationConnection.pageInfo":
		if e.complexity.OperationConnection.PageInfo == nil {
			break
		}

		return e.complexity.OperationConnection.PageInfo(childComplexity), true

	case "OperationConnection.totalCount":
		if e.complexity.OperationConnection.TotalCount == nil {
			break
		}

		return e.complexity.OperationConnection.TotalCount(childComplexity), true

	case "OperationEdge.cursor":
		if e.complexity.OperationEdge.Cursor == nil {
			break
		}

		return e.complexity.OperationEdge.Cursor(childComplexity), true

	case "OperationEdge.node":
		if e.complexity.OperationEdge.Node == nil {
			break
		}

		return e.complexity.OperationEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.repository":
		if e.complexity.Query.Repository == nil {
			break
		}

		args, err := ec.field_Query_repository_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repository(childComplexity, args["ref"].(*string)), true

	case "Repository.allBugs":
		if e.complexity.Repository.AllBugs == nil {
			break
		}

		args, err := ec.field_Repository_allBugs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.AllBugs(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int), args["query"].(*string)), true

	case "Repository.allIdentities":
		if e.complexity.Repository.AllIdentities == nil {
			break
		}

		args, err := ec.field_Repository_allIdentities_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.AllIdentities(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Repository.bug":
		if e.complexity.Repository.Bug == nil {
			break
		}

		args, err := ec.field_Repository_bug_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Bug(childComplexity, args["prefix"].(string)), true

	case "Repository.identity":
		if e.complexity.Repository.Identity == nil {
			break
		}

		args, err := ec.field_Repository_identity_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Identity(childComplexity, args["prefix"].(string)), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.userIdentity":
		if e.complexity.Repository.UserIdentity == nil {
			break
		}

		return e.complexity.Repository.UserIdentity(childComplexity), true

	case "Repository.validLabels":
		if e.complexity.Repository.ValidLabels == nil {
			break
		}

		args, err := ec.field_Repository_validLabels_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.ValidLabels(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBugAddCommentAndCloseInput,
		ec.unmarshalInputBugAddCommentAndReopenInput,
		ec.unmarshalInputBugAddCommentInput,
		ec.unmarshalInputBugChangeLabelInput,
		ec.unmarshalInputBugCreateInput,
		ec.unmarshalInputBugEditCommentInput,
		ec.unmarshalInputBugSetTitleInput,
		ec.unmarshalInputBugStatusCloseInput,
		ec.unmarshalInputBugStatusOpenInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/bug.graphql", Input: `type Bug implements Authored {
  """The identifier for this bug"""
  id: ID!
  """The human version (truncated) identifier for this bug"""
  humanId: String!
  status: Status!
  title: String!
  labels: [Label!]!
  author: Identity!
  createdAt: Time!
  lastEdit: Time!

  """The actors of the bug. Actors are Identity that have interacted with the bug."""
  actors(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): IdentityConnection!

  """The participants of the bug. Participants are Identity that have created or
  added a comment on the bug."""
  participants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): IdentityConnection!

  comments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): BugCommentConnection!

  timeline(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): BugTimelineItemConnection!

  operations(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """Returns the elements in the list that come before the specified cursor."""
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): OperationConnection!
}

"""The connection type for Bug."""
type BugConnection {
  """A list of edges."""
  edges: [BugEdge!]!
  nodes: [Bug!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type BugEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Bug!
}
`, BuiltIn: false},
	{Name: "../schema/bug_comment.graphql", Input: `"""Represents a comment on a bug."""
type BugComment implements Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.Comment") {
    id: CombinedId! @goField(name: "CombinedId")

    """The author of this comment."""
    author: Identity!

    """The message of this comment."""
    message: String!

    """All media's hash referenced in this comment"""
    files: [Hash!]!
}

type BugCommentConnection {
    edges: [BugCommentEdge!]!
    nodes: [BugComment!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type BugCommentEdge {
    cursor: String!
    node: BugComment!
}
`, BuiltIn: false},
	{Name: "../schema/bug_mutations.graphql", Input: `extend type Mutation {
    """Create a new bug"""
    bugCreate(input: BugCreateInput!): BugCreatePayload!
    """Add a new comment to a bug"""
    bugAddComment(input: BugAddCommentInput!): BugAddCommentPayload!
    """Add a new comment to a bug and close it"""
    bugAddCommentAndClose(input: BugAddCommentAndCloseInput!): BugAddCommentAndClosePayload!
    """Add a new comment to a bug and reopen it"""
    bugAddCommentAndReopen(input: BugAddCommentAndReopenInput!): BugAddCommentAndReopenPayload!
    """Change a comment of a bug"""
    bugEditComment(input: BugEditCommentInput!): BugEditCommentPayload!
    """Add or remove a set of label on a bug"""
    bugChangeLabels(input: BugChangeLabelInput): BugChangeLabelPayload!
    """Change a bug's status to open"""
    bugStatusOpen(input: BugStatusOpenInput!): BugStatusOpenPayload!
    """Change a bug's status to closed"""
    bugStatusClose(input: BugStatusCloseInput!): BugStatusClosePayload!
    """Change a bug's title"""
    bugSetTitle(input: BugSetTitleInput!): BugSetTitlePayload!
}

input BugCreateInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The title of the new bug."""
    title: String!
    """The first message of the new bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type BugCreatePayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The created bug."""
    bug: Bug!
    """The resulting operation."""
    operation: BugCreateOperation!
}

input BugAddCommentInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The message to be added to the bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type BugAddCommentPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: BugAddCommentOperation!
}

input BugAddCommentAndCloseInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The message to be added to the bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type BugAddCommentAndClosePayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting AddComment operation."""
    commentOperation: BugAddCommentOperation!
    """The resulting SetStatusOperation."""
    statusOperation: BugSetStatusOperation!
}

input BugAddCommentAndReopenInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The message to be added to the bug."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type BugAddCommentAndReopenPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting AddComment operation."""
    commentOperation: BugAddCommentOperation!
    """The resulting SetStatusOperation."""
    statusOperation: BugSetStatusOperation!
}

input BugEditCommentInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """A prefix of the CombinedId of the comment to be changed."""
    targetPrefix: String!
    """The new message to be set."""
    message: String!
    """The collection of file's hash required for the first message."""
    files: [Hash!]
}

type BugEditCommentPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: BugEditCommentOperation!
}

input BugChangeLabelInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The list of label to add."""
    added: [String!]
    """The list of label to remove."""
    Removed: [String!]
}

type BugChangeLabelPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: BugLabelChangeOperation!
    """The effect each source label had."""
    results: [LabelChangeResult]!
}

input BugStatusOpenInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
}

type BugStatusOpenPayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: BugSetStatusOperation!
}

input BugStatusCloseInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
}

type BugStatusClosePayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation."""
    operation: BugSetStatusOperation!
}

input BugSetTitleInput {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The name of the repository. If not set, the default repository is used."""
    repoRef: String
    """The bug ID's prefix."""
    prefix: String!
    """The new title."""
    title: String!
}

type BugSetTitlePayload {
    """A unique identifier for the client performing the mutation."""
    clientMutationId: String
    """The affected bug."""
    bug: Bug!
    """The resulting operation"""
    operation: BugSetTitleOperation!
}
`, BuiltIn: false},
	{Name: "../schema/bug_operations.graphql", Input: `type BugCreateOperation implements Operation & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.CreateOperation") {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")

    title: String!
    message: String!
    files: [Hash!]!
}

type BugSetTitleOperation implements Operation & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.SetTitleOperation") {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")

    title: String!
    was: String!
}

type BugAddCommentOperation implements Operation & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.AddCommentOperation") {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")

    message: String!
    files: [Hash!]!
}

type BugEditCommentOperation implements Operation & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.EditCommentOperation") {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")

    target: String!
    message: String!
    files: [Hash!]!
}

type BugSetStatusOperation implements Operation & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.SetStatusOperation") {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")

    status: Status!
}

type BugLabelChangeOperation implements Operation & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.LabelChangeOperation") {
    """The identifier of the operation"""
    id: ID!
    """The author of this object."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")

    added: [Label!]!
    removed: [Label!]!
}
`, BuiltIn: false},
	{Name: "../schema/bug_timeline.graphql", Input: `"""An item in the timeline of bug events"""
interface BugTimelineItem
@goModel(model: "github.com/git-bug/git-bug/entities/bug.TimelineItem") {
    """The identifier of the source operation"""
    id: CombinedId!
}

"""CommentHistoryStep hold one version of a message in the history"""
type BugCommentHistoryStep
@goModel(model: "github.com/git-bug/git-bug/entities/bug.CommentHistoryStep") {
    message: String!
    date: Time!
}

# Connection

"""The connection type for TimelineItem"""
type BugTimelineItemConnection {
    edges: [BugTimelineItemEdge!]!
    nodes: [BugTimelineItem!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

"""Represent a TimelineItem"""
type BugTimelineItemEdge {
    cursor: String!
    node: BugTimelineItem!
}

# Items

"""BugCreateTimelineItem is a BugTimelineItem that represent the creation of a bug and its message edition history"""
type BugCreateTimelineItem implements BugTimelineItem & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.CreateTimelineItem") {
    """The identifier of the source operation"""
    id: CombinedId! @goField(name: "CombinedId")
    author: Identity!
    message: String!
    messageIsEmpty: Boolean!
    files: [Hash!]!
    createdAt: Time!
    lastEdit: Time!
    edited: Boolean!
    history: [BugCommentHistoryStep!]!
}

"""BugAddCommentTimelineItem is a BugTimelineItem that represent a BugComment and its edition history"""
type BugAddCommentTimelineItem implements BugTimelineItem & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.AddCommentTimelineItem") {
    """The identifier of the source operation"""
    id: CombinedId! @goField(name: "CombinedId")
    author: Identity!
    message: String!
    messageIsEmpty: Boolean!
    files: [Hash!]!
    createdAt: Time!
    lastEdit: Time!
    edited: Boolean!
    history: [BugCommentHistoryStep!]!
}

"""BugLabelChangeTimelineItem is a BugTimelineItem that represent a change in the labels of a bug"""
type BugLabelChangeTimelineItem implements BugTimelineItem & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.LabelChangeTimelineItem") {
    """The identifier of the source operation"""
    id: CombinedId! @goField(name: "CombinedId")
    author: Identity!
    date: Time!
    added: [Label!]!
    removed: [Label!]!
}

"""BugSetStatusTimelineItem is a BugTimelineItem that represent a change in the status of a bug"""
type BugSetStatusTimelineItem implements BugTimelineItem & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.SetStatusTimelineItem") {
    """The identifier of the source operation"""
    id: CombinedId! @goField(name: "CombinedId")
    author: Identity!
    date: Time!
    status: Status!
}

"""BugLabelChangeTimelineItem is a BugTimelineItem that represent a change in the title of a bug"""
type BugSetTitleTimelineItem implements BugTimelineItem & Authored
@goModel(model: "github.com/git-bug/git-bug/entities/bug.SetTitleTimelineItem") {
    """The identifier of the source operation"""
    id: CombinedId! @goField(name: "CombinedId")
    author: Identity!
    date: Time!
    title: String!
    was: String!
}
`, BuiltIn: false},
	{Name: "../schema/directives.graphql", Input: `# Below are directives defined by gqlgen, see https://gqlgen.com/config/

directive @goModel(
    model: String
    models: [String!]
    forceGenerate: Boolean
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
    omittable: Boolean
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../schema/identity.graphql", Input: `"""Represents an identity"""
type Identity {
    """The identifier for this identity"""
    id: ID!
    """The human version (truncated) identifier for this identity"""
    humanId: String!
    """The name of the person, if known."""
    name: String
    """The email of the person, if known."""
    email: String
    """The login of the person, if known."""
    login: String
    """A non-empty string to display, representing the identity, based on the non-empty values."""
    displayName: String!
    """An url to an avatar"""
    avatarUrl: String
    """isProtected is true if the chain of git commits started to be signed.
    If that's the case, only signed commit with a valid key for this identity can be added."""
    isProtected: Boolean!
}

type IdentityConnection {
    edges: [IdentityEdge!]!
    nodes: [Identity!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type IdentityEdge {
    cursor: String!
    node: Identity!
}
`, BuiltIn: false},
	{Name: "../schema/label.graphql", Input: `"""Label for a bug."""
type Label {
    """The name of the label."""
    name: String!
    """Color of the label."""
    color: Color!
}

type LabelConnection {
    edges: [LabelEdge!]!
    nodes: [Label!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type LabelEdge {
    cursor: String!
    node: Label!
}

enum LabelChangeStatus {
    ADDED
    REMOVED
    DUPLICATE_IN_OP
    ALREADY_SET
    DOESNT_EXIST
}

type LabelChangeResult {
    """The source label."""
    label: Label!
    """The effect this label had."""
    status: LabelChangeStatus!
}
`, BuiltIn: false},
	{Name: "../schema/operation.graphql", Input: `"""An operation applied to an entity."""
interface Operation {
    """The identifier of the operation"""
    id: ID!
    """The operations author."""
    author: Identity!
    """The datetime when this operation was issued."""
    date: Time! @goField(name: "Time")
}

# Connection

"""The connection type for an Operation"""
type OperationConnection {
    edges: [OperationEdge!]!
    nodes: [Operation!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

"""Represent an Operation"""
type OperationEdge {
    cursor: String!
    node: Operation!
}
`, BuiltIn: false},
	{Name: "../schema/repository.graphql", Input: `type Repository {
    """The name of the repository"""
    name: String

    """All the bugs"""
    allBugs(
        """Returns the elements in the list that come after the specified cursor."""
        after: String
        """Returns the elements in the list that come before the specified cursor."""
        before: String
        """Returns the first _n_ elements from the list."""
        first: Int
        """Returns the last _n_ elements from the list."""
        last: Int
        """A query to select and order bugs."""
        query: String
    ): BugConnection!

    bug(prefix: String!): Bug

    """All the identities"""
    allIdentities(
        """Returns the elements in the list that come after the specified cursor."""
        after: String
        """Returns the elements in the list that come before the specified cursor."""
        before: String
        """Returns the first _n_ elements from the list."""
        first: Int
        """Returns the last _n_ elements from the list."""
        last: Int
    ): IdentityConnection!

    identity(prefix: String!): Identity

    """The identity created or selected by the user as its own"""
    userIdentity: Identity

    """List of valid labels."""
    validLabels(
        """Returns the elements in the list that come after the specified cursor."""
        after: String
        """Returns the elements in the list that come before the specified cursor."""
        before: String
        """Returns the first _n_ elements from the list."""
        first: Int
        """Returns the last _n_ elements from the list."""
        last: Int
    ): LabelConnection!
}
`, BuiltIn: false},
	{Name: "../schema/root.graphql", Input: `type Query {
    """Access a repository by reference/name. If no ref is given, the default repository is returned if any."""
    repository(ref: String): Repository
}

type Mutation # See each entity mutations
`, BuiltIn: false},
	{Name: "../schema/status.graphql", Input: `enum Status {
    OPEN
    CLOSED
}
`, BuiltIn: false},
	{Name: "../schema/types.graphql", Input: `scalar CombinedId
scalar Time
scalar Hash

"""Defines a color by red, green and blue components."""
type Color {
    """Red component of the color."""
    R: Int!
    """Green component of the color."""
    G: Int!
    """Blue component of the color."""
    B: Int!
}

"""Information about pagination in a connection."""
type PageInfo {
    """When paginating forwards, are there more items?"""
    hasNextPage: Boolean!
    """When paginating backwards, are there more items?"""
    hasPreviousPage: Boolean!
    """When paginating backwards, the cursor to continue."""
    startCursor: String!
    """When paginating forwards, the cursor to continue."""
    endCursor: String!
}

"""An object that has an author."""
interface Authored {
    """The author of this object."""
    author: Identity!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
